# Ten cryptography

Ten uses cryptography for:
- data authentication
- integrity
- Private communication and data storage. 
- SGX attestation


## Data authentication

We inherit the signature and hashing algorithm from Ethereum. Same as Ethereum, these are used by user wallets to sign over transaction, which are being checked before execution.

- secp256k1 for signing 
- keccak256 for hashing

The difference from Ethereum is that we have the concept of "Viewing keys" (see Wallet extension), which are also secp256k1 
and are used for authenticating "eth_call" requests, which are not authenticated in Ethereum. 


## Integrity

We use the same mechanisms as Ethereum. Transactions are executed against a local database containing the entire state.
For every "block", the producer of the block will publish the root of a Patricia Tree (calculated with keccak256), which
will get verified by the other nodes who have the power to challenge.


## Private communication and data storage

Privacy is a concern that is Ten-specific.

For protecting data-in-use we use SGX.

In this section we'll discuss how data is protected in transit and at rest.


### The Shared Secret 

Ten is a decentralised network of attested nodes that need to collaborate on building a ledger.
The ledger should only be visible inside the enclave program, and not to the outside world.

The requirement is that all data exiting the enclaves should be encrypted with keys known only to the enclaves.

The solution is for all the enclaves to know a "Shared Secret"(SS). 

The SS is 256 bits of entropy generated by the genesis enclave for each new major version, and then shared to the 
other nodes when they successfully prove their attestation.
Each node stores the SS locally sealed by their enclave.

The shared secret is the main ingredient to protecting data in transit and data at rest.

### Viewing keys

The other ingredient are viewing keys (VK).

VKs are secp256k1 keys generated locally by each user. They are used for authenticating "eth_call" requests, by signing over them, 
and for receiving encrypted responses which only that user can decrypt. 

VKs are signed by the actual account key as part of a transaction. This is the only step that requires a human interaction. 

VKs are certificates used behind the scenes by the Ten tooling to encrypt and authenticate traffic.

### Data in transit

By data in transit, we mean a few things:
- transactions submitted by end users.
- "eth_call" requests. Users calling smart contracts
- protocol communication between ten nodes (not yet used, so not covered).

#### The "Ten Key"

Client software must encrypt data with a key known only to the enclaves.

All enclaves will generate a secp256k1 key-pair by using the "Shared secret" as entropy. (Todo - is this secure?)
The enclaves publish the public key to the Management contract (Is it as part of the Attestation?)  

The Wallet extension will encrypt all data in transit from users with the OK which is visible only to the enclaves. 


### Data at rest

Data at rest is:
- the transactions as stored in Rollups
- the transactions as stored in the "Light Batches"
- the local database 


#### EdgelessDB

Ten uses EdglessDB as the local database, the equivalent of LevelDB in go-ethereum.

EdgelessDB runs inside an enclave. After the initial handshake attestation, the Ten Enclave will store the key
used for communication with Edgeless sealed with the enclave key.
Edb uses RocksDB behind the scenes and use AES-GCM to encrypt the backing files.


#### Storing transactions in rollups

The payload containing transactions must be stored encrypted in the data availability layer.
For efficiency it must be encrypted with symmetric keys.

The other important requirement is that transactions can be revealed. 

We propose to use with AES-128-GCM. 

The preferred approach is to encrypt transactions based on their revelation period.
Each rollup will contain N (probably 5 or less) payloads encrypted with different keys.

We propose to use HKDF to derive the AES keys from the shared secret.
The derivation is as follows: `Key_for_group(Rollup, Group_no)=HKDF(SHA256(Rollup_Hash || Group_no || Shared_secret))` (Todo - does this make sense?)

Note: Compression is very important to achieve cost efficiency. In case it turns out that the compressed size is significantly 
larger by compressing and encrypting the entire group of transactions as a whole, then we might consider that.
The advantage of releasing keys, as opposed to releasing decrypted transactions is the simplicity of the enclave code.

#### Storing transactions in batches

Batches are the units of data gossiped between the Ten nodes that provide soft finality.
The payload of each batch is encrypted with a:
`Key_for_Batch(Batch_Height)=HKDF(SHA256(BatchHeight || Shared_secret))` (Todo - does this make sense?)


## SGX Attestation Parameters

In order for the Ten enclave to be considered secure, besides the actual code running on up-to-date hardware, it also must be
configured with the right parameters.

The requirement is that a node operator should not be able to start an Ten Enclave (and obtain the Shared Secret) with 
parameters that allow them to extract secrets. 

Some configs will not change from one version to the nex, but must be configurable because the same codebase is used for both testing and production.

The configuration file must be passed when building the image using ego.
See (ego config)[https://docs.edgeless.systems/ego/reference/config]
The config file passed in will be included in the enclave measurement.

### Protected config parameters 

#### Business configs 
- Ten Chain Id
- Ethereum Chain Id
- Management Contract Address
- MessageBus Address
- Weak subjectivity checkpoint


#### Operational configs
- LogLevel and LogPath - in production these have to be set to values that don't leak any information

#### Derived configs
There are other derived configurations which will be derived. For example retrieved from the Management contract.

- NodeType - sequencer or validator
