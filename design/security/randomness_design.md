# Randomness in TEN design

## Scope

The purpose of this document is to describe how randomness is generated and exposed to TEN smart contracts. 

## Overview

In the latest version of Ethereum, smart contract developers generally use the `RANDOM` opcode for sources of pseudo random numbers, which uses randomness generated by the beacon chain.
This randomness is visible and known to everyone, and somehow under the control of the miners.

## Requirements
In Ten, our goal is to remove any control that the miners might have over randomness, while also keeping the randomness private per transaction.
This enables use cases such as games with hidden state. 

## Solution

1. The current aggregator working on a rollup generates a random 32 bytes number inside an enclave: `RND1`. This number will be published in the rollup header in the `MixDigest` field, and used in the formula for calculating the randomness exposed to smart contracts.
2. Every node verifying a rollup,(that includes the aggregator who builds the rollup), will calculate another secret `RND2 = HASH(RND1||SHARED_SECRET)`.
   This calculation is deterministic, and the result is a secret random number per rollup that is available only inside the enclave.
   
   *Note: It is not secure to use `RND2` as the randomness for all transactions in a rollup, because there could be a smart contract that could leak it.*

3. Next step is to compute a unique randomness per transaction:
   `RND3 = HASH(RND2||TX_COUNTER)`
   This `RND3` will be exposed to smart contracts as block.difficulty. It will be unique per transaction, and we assume it will be leaked.
   Given that the hash function is not reversible, it is not possible to work up to RND2 or the SHARED_SECRET from RND3.


### Notes

1. We need to generate `RND1` using the enclave, and not use some other entropy derived from the blockchain to avoid the possibility of gaming by aggregators. 
If the stakes are high enough, they could try different things until the entropy benefits them. The secure entropy inside the CPU is out of anyone's control, which removes this capability. Since we use secure enclaves with attested code, we can make sure that the program uses it. 

