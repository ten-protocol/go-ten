// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: enclave.proto

package generated

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	EnclaveProto_Status_FullMethodName                = "/generated.EnclaveProto/Status"
	EnclaveProto_Attestation_FullMethodName           = "/generated.EnclaveProto/Attestation"
	EnclaveProto_GenerateSecret_FullMethodName        = "/generated.EnclaveProto/GenerateSecret"
	EnclaveProto_InitEnclave_FullMethodName           = "/generated.EnclaveProto/InitEnclave"
	EnclaveProto_EnclaveID_FullMethodName             = "/generated.EnclaveProto/EnclaveID"
	EnclaveProto_RPCEncryptionKey_FullMethodName      = "/generated.EnclaveProto/RPCEncryptionKey"
	EnclaveProto_SubmitL1Block_FullMethodName         = "/generated.EnclaveProto/SubmitL1Block"
	EnclaveProto_EncryptedRPC_FullMethodName          = "/generated.EnclaveProto/EncryptedRPC"
	EnclaveProto_SubmitBatch_FullMethodName           = "/generated.EnclaveProto/SubmitBatch"
	EnclaveProto_Stop_FullMethodName                  = "/generated.EnclaveProto/Stop"
	EnclaveProto_GetCode_FullMethodName               = "/generated.EnclaveProto/GetCode"
	EnclaveProto_Subscribe_FullMethodName             = "/generated.EnclaveProto/Subscribe"
	EnclaveProto_Unsubscribe_FullMethodName           = "/generated.EnclaveProto/Unsubscribe"
	EnclaveProto_HealthCheck_FullMethodName           = "/generated.EnclaveProto/HealthCheck"
	EnclaveProto_GetBatch_FullMethodName              = "/generated.EnclaveProto/GetBatch"
	EnclaveProto_GetBatchBySeqNo_FullMethodName       = "/generated.EnclaveProto/GetBatchBySeqNo"
	EnclaveProto_GetRollupData_FullMethodName         = "/generated.EnclaveProto/GetRollupData"
	EnclaveProto_CreateBatch_FullMethodName           = "/generated.EnclaveProto/CreateBatch"
	EnclaveProto_CreateRollup_FullMethodName          = "/generated.EnclaveProto/CreateRollup"
	EnclaveProto_ExportCrossChainData_FullMethodName  = "/generated.EnclaveProto/ExportCrossChainData"
	EnclaveProto_DebugTraceTransaction_FullMethodName = "/generated.EnclaveProto/DebugTraceTransaction"
	EnclaveProto_StreamL2Updates_FullMethodName       = "/generated.EnclaveProto/StreamL2Updates"
	EnclaveProto_GetTotalContractCount_FullMethodName = "/generated.EnclaveProto/GetTotalContractCount"
	EnclaveProto_EnclavePublicConfig_FullMethodName   = "/generated.EnclaveProto/EnclavePublicConfig"
	EnclaveProto_MakeActive_FullMethodName            = "/generated.EnclaveProto/MakeActive"
)

// EnclaveProtoClient is the client API for EnclaveProto service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EnclaveProtoClient interface {
	Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	Attestation(ctx context.Context, in *AttestationRequest, opts ...grpc.CallOption) (*AttestationResponse, error)
	GenerateSecret(ctx context.Context, in *GenerateSecretRequest, opts ...grpc.CallOption) (*GenerateSecretResponse, error)
	InitEnclave(ctx context.Context, in *InitEnclaveRequest, opts ...grpc.CallOption) (*InitEnclaveResponse, error)
	EnclaveID(ctx context.Context, in *EnclaveIDRequest, opts ...grpc.CallOption) (*EnclaveIDResponse, error)
	RPCEncryptionKey(ctx context.Context, in *RPCEncryptionKeyRequest, opts ...grpc.CallOption) (*RPCEncryptionKeyResponse, error)
	SubmitL1Block(ctx context.Context, in *SubmitBlockRequest, opts ...grpc.CallOption) (*SubmitBlockResponse, error)
	EncryptedRPC(ctx context.Context, in *EncCallRequest, opts ...grpc.CallOption) (*EncCallResponse, error)
	SubmitBatch(ctx context.Context, in *SubmitBatchRequest, opts ...grpc.CallOption) (*SubmitBatchResponse, error)
	Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error)
	GetCode(ctx context.Context, in *GetCodeRequest, opts ...grpc.CallOption) (*GetCodeResponse, error)
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error)
	Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error)
	HealthCheck(ctx context.Context, in *EmptyArgs, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	GetBatch(ctx context.Context, in *GetBatchRequest, opts ...grpc.CallOption) (*GetBatchResponse, error)
	GetBatchBySeqNo(ctx context.Context, in *GetBatchBySeqNoRequest, opts ...grpc.CallOption) (*GetBatchResponse, error)
	GetRollupData(ctx context.Context, in *GetRollupDataRequest, opts ...grpc.CallOption) (*GetRollupDataResponse, error)
	CreateBatch(ctx context.Context, in *CreateBatchRequest, opts ...grpc.CallOption) (*CreateBatchResponse, error)
	CreateRollup(ctx context.Context, in *CreateRollupRequest, opts ...grpc.CallOption) (*CreateRollupResponse, error)
	ExportCrossChainData(ctx context.Context, in *ExportCrossChainDataRequest, opts ...grpc.CallOption) (*ExportCrossChainDataResponse, error)
	DebugTraceTransaction(ctx context.Context, in *DebugTraceTransactionRequest, opts ...grpc.CallOption) (*DebugTraceTransactionResponse, error)
	StreamL2Updates(ctx context.Context, in *StreamL2UpdatesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[EncodedUpdateResponse], error)
	GetTotalContractCount(ctx context.Context, in *GetTotalContractCountRequest, opts ...grpc.CallOption) (*GetTotalContractCountResponse, error)
	EnclavePublicConfig(ctx context.Context, in *EnclavePublicConfigRequest, opts ...grpc.CallOption) (*EnclavePublicConfigResponse, error)
	MakeActive(ctx context.Context, in *MakeActiveRequest, opts ...grpc.CallOption) (*MakeActiveResponse, error)
}

type enclaveProtoClient struct {
	cc grpc.ClientConnInterface
}

func NewEnclaveProtoClient(cc grpc.ClientConnInterface) EnclaveProtoClient {
	return &enclaveProtoClient{cc}
}

func (c *enclaveProtoClient) Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_Status_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) Attestation(ctx context.Context, in *AttestationRequest, opts ...grpc.CallOption) (*AttestationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AttestationResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_Attestation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GenerateSecret(ctx context.Context, in *GenerateSecretRequest, opts ...grpc.CallOption) (*GenerateSecretResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateSecretResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GenerateSecret_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) InitEnclave(ctx context.Context, in *InitEnclaveRequest, opts ...grpc.CallOption) (*InitEnclaveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitEnclaveResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_InitEnclave_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) EnclaveID(ctx context.Context, in *EnclaveIDRequest, opts ...grpc.CallOption) (*EnclaveIDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclaveIDResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_EnclaveID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) RPCEncryptionKey(ctx context.Context, in *RPCEncryptionKeyRequest, opts ...grpc.CallOption) (*RPCEncryptionKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RPCEncryptionKeyResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_RPCEncryptionKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) SubmitL1Block(ctx context.Context, in *SubmitBlockRequest, opts ...grpc.CallOption) (*SubmitBlockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitBlockResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_SubmitL1Block_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) EncryptedRPC(ctx context.Context, in *EncCallRequest, opts ...grpc.CallOption) (*EncCallResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncCallResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_EncryptedRPC_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) SubmitBatch(ctx context.Context, in *SubmitBatchRequest, opts ...grpc.CallOption) (*SubmitBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitBatchResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_SubmitBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_Stop_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetCode(ctx context.Context, in *GetCodeRequest, opts ...grpc.CallOption) (*GetCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCodeResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GetCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubscribeResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_Subscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnsubscribeResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_Unsubscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) HealthCheck(ctx context.Context, in *EmptyArgs, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetBatch(ctx context.Context, in *GetBatchRequest, opts ...grpc.CallOption) (*GetBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBatchResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GetBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetBatchBySeqNo(ctx context.Context, in *GetBatchBySeqNoRequest, opts ...grpc.CallOption) (*GetBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBatchResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GetBatchBySeqNo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetRollupData(ctx context.Context, in *GetRollupDataRequest, opts ...grpc.CallOption) (*GetRollupDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRollupDataResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GetRollupData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) CreateBatch(ctx context.Context, in *CreateBatchRequest, opts ...grpc.CallOption) (*CreateBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateBatchResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_CreateBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) CreateRollup(ctx context.Context, in *CreateRollupRequest, opts ...grpc.CallOption) (*CreateRollupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateRollupResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_CreateRollup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) ExportCrossChainData(ctx context.Context, in *ExportCrossChainDataRequest, opts ...grpc.CallOption) (*ExportCrossChainDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportCrossChainDataResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_ExportCrossChainData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) DebugTraceTransaction(ctx context.Context, in *DebugTraceTransactionRequest, opts ...grpc.CallOption) (*DebugTraceTransactionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DebugTraceTransactionResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_DebugTraceTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) StreamL2Updates(ctx context.Context, in *StreamL2UpdatesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[EncodedUpdateResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &EnclaveProto_ServiceDesc.Streams[0], EnclaveProto_StreamL2Updates_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamL2UpdatesRequest, EncodedUpdateResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EnclaveProto_StreamL2UpdatesClient = grpc.ServerStreamingClient[EncodedUpdateResponse]

func (c *enclaveProtoClient) GetTotalContractCount(ctx context.Context, in *GetTotalContractCountRequest, opts ...grpc.CallOption) (*GetTotalContractCountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTotalContractCountResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_GetTotalContractCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) EnclavePublicConfig(ctx context.Context, in *EnclavePublicConfigRequest, opts ...grpc.CallOption) (*EnclavePublicConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnclavePublicConfigResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_EnclavePublicConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) MakeActive(ctx context.Context, in *MakeActiveRequest, opts ...grpc.CallOption) (*MakeActiveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MakeActiveResponse)
	err := c.cc.Invoke(ctx, EnclaveProto_MakeActive_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EnclaveProtoServer is the server API for EnclaveProto service.
// All implementations must embed UnimplementedEnclaveProtoServer
// for forward compatibility.
type EnclaveProtoServer interface {
	Status(context.Context, *StatusRequest) (*StatusResponse, error)
	Attestation(context.Context, *AttestationRequest) (*AttestationResponse, error)
	GenerateSecret(context.Context, *GenerateSecretRequest) (*GenerateSecretResponse, error)
	InitEnclave(context.Context, *InitEnclaveRequest) (*InitEnclaveResponse, error)
	EnclaveID(context.Context, *EnclaveIDRequest) (*EnclaveIDResponse, error)
	RPCEncryptionKey(context.Context, *RPCEncryptionKeyRequest) (*RPCEncryptionKeyResponse, error)
	SubmitL1Block(context.Context, *SubmitBlockRequest) (*SubmitBlockResponse, error)
	EncryptedRPC(context.Context, *EncCallRequest) (*EncCallResponse, error)
	SubmitBatch(context.Context, *SubmitBatchRequest) (*SubmitBatchResponse, error)
	Stop(context.Context, *StopRequest) (*StopResponse, error)
	GetCode(context.Context, *GetCodeRequest) (*GetCodeResponse, error)
	Subscribe(context.Context, *SubscribeRequest) (*SubscribeResponse, error)
	Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error)
	HealthCheck(context.Context, *EmptyArgs) (*HealthCheckResponse, error)
	GetBatch(context.Context, *GetBatchRequest) (*GetBatchResponse, error)
	GetBatchBySeqNo(context.Context, *GetBatchBySeqNoRequest) (*GetBatchResponse, error)
	GetRollupData(context.Context, *GetRollupDataRequest) (*GetRollupDataResponse, error)
	CreateBatch(context.Context, *CreateBatchRequest) (*CreateBatchResponse, error)
	CreateRollup(context.Context, *CreateRollupRequest) (*CreateRollupResponse, error)
	ExportCrossChainData(context.Context, *ExportCrossChainDataRequest) (*ExportCrossChainDataResponse, error)
	DebugTraceTransaction(context.Context, *DebugTraceTransactionRequest) (*DebugTraceTransactionResponse, error)
	StreamL2Updates(*StreamL2UpdatesRequest, grpc.ServerStreamingServer[EncodedUpdateResponse]) error
	GetTotalContractCount(context.Context, *GetTotalContractCountRequest) (*GetTotalContractCountResponse, error)
	EnclavePublicConfig(context.Context, *EnclavePublicConfigRequest) (*EnclavePublicConfigResponse, error)
	MakeActive(context.Context, *MakeActiveRequest) (*MakeActiveResponse, error)
	mustEmbedUnimplementedEnclaveProtoServer()
}

// UnimplementedEnclaveProtoServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEnclaveProtoServer struct{}

func (UnimplementedEnclaveProtoServer) Status(context.Context, *StatusRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedEnclaveProtoServer) Attestation(context.Context, *AttestationRequest) (*AttestationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Attestation not implemented")
}
func (UnimplementedEnclaveProtoServer) GenerateSecret(context.Context, *GenerateSecretRequest) (*GenerateSecretResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateSecret not implemented")
}
func (UnimplementedEnclaveProtoServer) InitEnclave(context.Context, *InitEnclaveRequest) (*InitEnclaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitEnclave not implemented")
}
func (UnimplementedEnclaveProtoServer) EnclaveID(context.Context, *EnclaveIDRequest) (*EnclaveIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnclaveID not implemented")
}
func (UnimplementedEnclaveProtoServer) RPCEncryptionKey(context.Context, *RPCEncryptionKeyRequest) (*RPCEncryptionKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RPCEncryptionKey not implemented")
}
func (UnimplementedEnclaveProtoServer) SubmitL1Block(context.Context, *SubmitBlockRequest) (*SubmitBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitL1Block not implemented")
}
func (UnimplementedEnclaveProtoServer) EncryptedRPC(context.Context, *EncCallRequest) (*EncCallResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptedRPC not implemented")
}
func (UnimplementedEnclaveProtoServer) SubmitBatch(context.Context, *SubmitBatchRequest) (*SubmitBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitBatch not implemented")
}
func (UnimplementedEnclaveProtoServer) Stop(context.Context, *StopRequest) (*StopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (UnimplementedEnclaveProtoServer) GetCode(context.Context, *GetCodeRequest) (*GetCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCode not implemented")
}
func (UnimplementedEnclaveProtoServer) Subscribe(context.Context, *SubscribeRequest) (*SubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedEnclaveProtoServer) Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unsubscribe not implemented")
}
func (UnimplementedEnclaveProtoServer) HealthCheck(context.Context, *EmptyArgs) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedEnclaveProtoServer) GetBatch(context.Context, *GetBatchRequest) (*GetBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBatch not implemented")
}
func (UnimplementedEnclaveProtoServer) GetBatchBySeqNo(context.Context, *GetBatchBySeqNoRequest) (*GetBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBatchBySeqNo not implemented")
}
func (UnimplementedEnclaveProtoServer) GetRollupData(context.Context, *GetRollupDataRequest) (*GetRollupDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRollupData not implemented")
}
func (UnimplementedEnclaveProtoServer) CreateBatch(context.Context, *CreateBatchRequest) (*CreateBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBatch not implemented")
}
func (UnimplementedEnclaveProtoServer) CreateRollup(context.Context, *CreateRollupRequest) (*CreateRollupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRollup not implemented")
}
func (UnimplementedEnclaveProtoServer) ExportCrossChainData(context.Context, *ExportCrossChainDataRequest) (*ExportCrossChainDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportCrossChainData not implemented")
}
func (UnimplementedEnclaveProtoServer) DebugTraceTransaction(context.Context, *DebugTraceTransactionRequest) (*DebugTraceTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DebugTraceTransaction not implemented")
}
func (UnimplementedEnclaveProtoServer) StreamL2Updates(*StreamL2UpdatesRequest, grpc.ServerStreamingServer[EncodedUpdateResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamL2Updates not implemented")
}
func (UnimplementedEnclaveProtoServer) GetTotalContractCount(context.Context, *GetTotalContractCountRequest) (*GetTotalContractCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTotalContractCount not implemented")
}
func (UnimplementedEnclaveProtoServer) EnclavePublicConfig(context.Context, *EnclavePublicConfigRequest) (*EnclavePublicConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnclavePublicConfig not implemented")
}
func (UnimplementedEnclaveProtoServer) MakeActive(context.Context, *MakeActiveRequest) (*MakeActiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakeActive not implemented")
}
func (UnimplementedEnclaveProtoServer) mustEmbedUnimplementedEnclaveProtoServer() {}
func (UnimplementedEnclaveProtoServer) testEmbeddedByValue()                      {}

// UnsafeEnclaveProtoServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EnclaveProtoServer will
// result in compilation errors.
type UnsafeEnclaveProtoServer interface {
	mustEmbedUnimplementedEnclaveProtoServer()
}

func RegisterEnclaveProtoServer(s grpc.ServiceRegistrar, srv EnclaveProtoServer) {
	// If the following call pancis, it indicates UnimplementedEnclaveProtoServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EnclaveProto_ServiceDesc, srv)
}

func _EnclaveProto_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_Status_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).Status(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_Attestation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttestationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).Attestation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_Attestation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).Attestation(ctx, req.(*AttestationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GenerateSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GenerateSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GenerateSecret_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GenerateSecret(ctx, req.(*GenerateSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_InitEnclave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitEnclaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).InitEnclave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_InitEnclave_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).InitEnclave(ctx, req.(*InitEnclaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_EnclaveID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnclaveIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).EnclaveID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_EnclaveID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).EnclaveID(ctx, req.(*EnclaveIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_RPCEncryptionKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCEncryptionKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).RPCEncryptionKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_RPCEncryptionKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).RPCEncryptionKey(ctx, req.(*RPCEncryptionKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_SubmitL1Block_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).SubmitL1Block(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_SubmitL1Block_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).SubmitL1Block(ctx, req.(*SubmitBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_EncryptedRPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncCallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).EncryptedRPC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_EncryptedRPC_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).EncryptedRPC(ctx, req.(*EncCallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_SubmitBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).SubmitBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_SubmitBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).SubmitBatch(ctx, req.(*SubmitBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_Stop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).Stop(ctx, req.(*StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GetCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetCode(ctx, req.(*GetCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_Subscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).Subscribe(ctx, req.(*SubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).Unsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_Unsubscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).Unsubscribe(ctx, req.(*UnsubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).HealthCheck(ctx, req.(*EmptyArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GetBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetBatch(ctx, req.(*GetBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetBatchBySeqNo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBatchBySeqNoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetBatchBySeqNo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GetBatchBySeqNo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetBatchBySeqNo(ctx, req.(*GetBatchBySeqNoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetRollupData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRollupDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetRollupData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GetRollupData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetRollupData(ctx, req.(*GetRollupDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_CreateBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).CreateBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_CreateBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).CreateBatch(ctx, req.(*CreateBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_CreateRollup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRollupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).CreateRollup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_CreateRollup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).CreateRollup(ctx, req.(*CreateRollupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_ExportCrossChainData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportCrossChainDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).ExportCrossChainData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_ExportCrossChainData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).ExportCrossChainData(ctx, req.(*ExportCrossChainDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_DebugTraceTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DebugTraceTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).DebugTraceTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_DebugTraceTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).DebugTraceTransaction(ctx, req.(*DebugTraceTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_StreamL2Updates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamL2UpdatesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EnclaveProtoServer).StreamL2Updates(m, &grpc.GenericServerStream[StreamL2UpdatesRequest, EncodedUpdateResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EnclaveProto_StreamL2UpdatesServer = grpc.ServerStreamingServer[EncodedUpdateResponse]

func _EnclaveProto_GetTotalContractCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTotalContractCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetTotalContractCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_GetTotalContractCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetTotalContractCount(ctx, req.(*GetTotalContractCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_EnclavePublicConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnclavePublicConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).EnclavePublicConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_EnclavePublicConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).EnclavePublicConfig(ctx, req.(*EnclavePublicConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_MakeActive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MakeActiveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).MakeActive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnclaveProto_MakeActive_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).MakeActive(ctx, req.(*MakeActiveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EnclaveProto_ServiceDesc is the grpc.ServiceDesc for EnclaveProto service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EnclaveProto_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "generated.EnclaveProto",
	HandlerType: (*EnclaveProtoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _EnclaveProto_Status_Handler,
		},
		{
			MethodName: "Attestation",
			Handler:    _EnclaveProto_Attestation_Handler,
		},
		{
			MethodName: "GenerateSecret",
			Handler:    _EnclaveProto_GenerateSecret_Handler,
		},
		{
			MethodName: "InitEnclave",
			Handler:    _EnclaveProto_InitEnclave_Handler,
		},
		{
			MethodName: "EnclaveID",
			Handler:    _EnclaveProto_EnclaveID_Handler,
		},
		{
			MethodName: "RPCEncryptionKey",
			Handler:    _EnclaveProto_RPCEncryptionKey_Handler,
		},
		{
			MethodName: "SubmitL1Block",
			Handler:    _EnclaveProto_SubmitL1Block_Handler,
		},
		{
			MethodName: "EncryptedRPC",
			Handler:    _EnclaveProto_EncryptedRPC_Handler,
		},
		{
			MethodName: "SubmitBatch",
			Handler:    _EnclaveProto_SubmitBatch_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _EnclaveProto_Stop_Handler,
		},
		{
			MethodName: "GetCode",
			Handler:    _EnclaveProto_GetCode_Handler,
		},
		{
			MethodName: "Subscribe",
			Handler:    _EnclaveProto_Subscribe_Handler,
		},
		{
			MethodName: "Unsubscribe",
			Handler:    _EnclaveProto_Unsubscribe_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _EnclaveProto_HealthCheck_Handler,
		},
		{
			MethodName: "GetBatch",
			Handler:    _EnclaveProto_GetBatch_Handler,
		},
		{
			MethodName: "GetBatchBySeqNo",
			Handler:    _EnclaveProto_GetBatchBySeqNo_Handler,
		},
		{
			MethodName: "GetRollupData",
			Handler:    _EnclaveProto_GetRollupData_Handler,
		},
		{
			MethodName: "CreateBatch",
			Handler:    _EnclaveProto_CreateBatch_Handler,
		},
		{
			MethodName: "CreateRollup",
			Handler:    _EnclaveProto_CreateRollup_Handler,
		},
		{
			MethodName: "ExportCrossChainData",
			Handler:    _EnclaveProto_ExportCrossChainData_Handler,
		},
		{
			MethodName: "DebugTraceTransaction",
			Handler:    _EnclaveProto_DebugTraceTransaction_Handler,
		},
		{
			MethodName: "GetTotalContractCount",
			Handler:    _EnclaveProto_GetTotalContractCount_Handler,
		},
		{
			MethodName: "EnclavePublicConfig",
			Handler:    _EnclaveProto_EnclavePublicConfig_Handler,
		},
		{
			MethodName: "MakeActive",
			Handler:    _EnclaveProto_MakeActive_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamL2Updates",
			Handler:       _EnclaveProto_StreamL2Updates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "enclave.proto",
}
