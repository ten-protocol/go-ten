// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.24.3
// source: enclave.proto

package generated

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// EnclaveProtoClient is the client API for EnclaveProto service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EnclaveProtoClient interface {
	Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	Attestation(ctx context.Context, in *AttestationRequest, opts ...grpc.CallOption) (*AttestationResponse, error)
	GenerateSecret(ctx context.Context, in *GenerateSecretRequest, opts ...grpc.CallOption) (*GenerateSecretResponse, error)
	InitEnclave(ctx context.Context, in *InitEnclaveRequest, opts ...grpc.CallOption) (*InitEnclaveResponse, error)
	EnclaveID(ctx context.Context, in *EnclaveIDRequest, opts ...grpc.CallOption) (*EnclaveIDResponse, error)
	RPCEncryptionKey(ctx context.Context, in *RPCEncryptionKeyRequest, opts ...grpc.CallOption) (*RPCEncryptionKeyResponse, error)
	SubmitL1Block(ctx context.Context, in *SubmitBlockRequest, opts ...grpc.CallOption) (*SubmitBlockResponse, error)
	EncryptedRPC(ctx context.Context, in *EncCallRequest, opts ...grpc.CallOption) (*EncCallResponse, error)
	SubmitBatch(ctx context.Context, in *SubmitBatchRequest, opts ...grpc.CallOption) (*SubmitBatchResponse, error)
	Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error)
	GetCode(ctx context.Context, in *GetCodeRequest, opts ...grpc.CallOption) (*GetCodeResponse, error)
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error)
	Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error)
	HealthCheck(ctx context.Context, in *EmptyArgs, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	GetBatch(ctx context.Context, in *GetBatchRequest, opts ...grpc.CallOption) (*GetBatchResponse, error)
	GetBatchBySeqNo(ctx context.Context, in *GetBatchBySeqNoRequest, opts ...grpc.CallOption) (*GetBatchResponse, error)
	GetRollupData(ctx context.Context, in *GetRollupDataRequest, opts ...grpc.CallOption) (*GetRollupDataResponse, error)
	CreateBatch(ctx context.Context, in *CreateBatchRequest, opts ...grpc.CallOption) (*CreateBatchResponse, error)
	CreateRollup(ctx context.Context, in *CreateRollupRequest, opts ...grpc.CallOption) (*CreateRollupResponse, error)
	ExportCrossChainData(ctx context.Context, in *ExportCrossChainDataRequest, opts ...grpc.CallOption) (*ExportCrossChainDataResponse, error)
	DebugTraceTransaction(ctx context.Context, in *DebugTraceTransactionRequest, opts ...grpc.CallOption) (*DebugTraceTransactionResponse, error)
	StreamL2Updates(ctx context.Context, in *StreamL2UpdatesRequest, opts ...grpc.CallOption) (EnclaveProto_StreamL2UpdatesClient, error)
	GetTotalContractCount(ctx context.Context, in *GetTotalContractCountRequest, opts ...grpc.CallOption) (*GetTotalContractCountResponse, error)
	EnclavePublicConfig(ctx context.Context, in *EnclavePublicConfigRequest, opts ...grpc.CallOption) (*EnclavePublicConfigResponse, error)
	MakeActive(ctx context.Context, in *MakeActiveRequest, opts ...grpc.CallOption) (*MakeActiveResponse, error)
}

type enclaveProtoClient struct {
	cc grpc.ClientConnInterface
}

func NewEnclaveProtoClient(cc grpc.ClientConnInterface) EnclaveProtoClient {
	return &enclaveProtoClient{cc}
}

func (c *enclaveProtoClient) Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/Status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) Attestation(ctx context.Context, in *AttestationRequest, opts ...grpc.CallOption) (*AttestationResponse, error) {
	out := new(AttestationResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/Attestation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GenerateSecret(ctx context.Context, in *GenerateSecretRequest, opts ...grpc.CallOption) (*GenerateSecretResponse, error) {
	out := new(GenerateSecretResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/GenerateSecret", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) InitEnclave(ctx context.Context, in *InitEnclaveRequest, opts ...grpc.CallOption) (*InitEnclaveResponse, error) {
	out := new(InitEnclaveResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/InitEnclave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) EnclaveID(ctx context.Context, in *EnclaveIDRequest, opts ...grpc.CallOption) (*EnclaveIDResponse, error) {
	out := new(EnclaveIDResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/EnclaveID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) RPCEncryptionKey(ctx context.Context, in *RPCEncryptionKeyRequest, opts ...grpc.CallOption) (*RPCEncryptionKeyResponse, error) {
	out := new(RPCEncryptionKeyResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/RPCEncryptionKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) SubmitL1Block(ctx context.Context, in *SubmitBlockRequest, opts ...grpc.CallOption) (*SubmitBlockResponse, error) {
	out := new(SubmitBlockResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/SubmitL1Block", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) EncryptedRPC(ctx context.Context, in *EncCallRequest, opts ...grpc.CallOption) (*EncCallResponse, error) {
	out := new(EncCallResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/EncryptedRPC", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) SubmitBatch(ctx context.Context, in *SubmitBatchRequest, opts ...grpc.CallOption) (*SubmitBatchResponse, error) {
	out := new(SubmitBatchResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/SubmitBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error) {
	out := new(StopResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetCode(ctx context.Context, in *GetCodeRequest, opts ...grpc.CallOption) (*GetCodeResponse, error) {
	out := new(GetCodeResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/GetCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error) {
	out := new(SubscribeResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/Subscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error) {
	out := new(UnsubscribeResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/Unsubscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) HealthCheck(ctx context.Context, in *EmptyArgs, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/HealthCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetBatch(ctx context.Context, in *GetBatchRequest, opts ...grpc.CallOption) (*GetBatchResponse, error) {
	out := new(GetBatchResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/GetBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetBatchBySeqNo(ctx context.Context, in *GetBatchBySeqNoRequest, opts ...grpc.CallOption) (*GetBatchResponse, error) {
	out := new(GetBatchResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/GetBatchBySeqNo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) GetRollupData(ctx context.Context, in *GetRollupDataRequest, opts ...grpc.CallOption) (*GetRollupDataResponse, error) {
	out := new(GetRollupDataResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/GetRollupData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) CreateBatch(ctx context.Context, in *CreateBatchRequest, opts ...grpc.CallOption) (*CreateBatchResponse, error) {
	out := new(CreateBatchResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/CreateBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) CreateRollup(ctx context.Context, in *CreateRollupRequest, opts ...grpc.CallOption) (*CreateRollupResponse, error) {
	out := new(CreateRollupResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/CreateRollup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) ExportCrossChainData(ctx context.Context, in *ExportCrossChainDataRequest, opts ...grpc.CallOption) (*ExportCrossChainDataResponse, error) {
	out := new(ExportCrossChainDataResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/ExportCrossChainData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) DebugTraceTransaction(ctx context.Context, in *DebugTraceTransactionRequest, opts ...grpc.CallOption) (*DebugTraceTransactionResponse, error) {
	out := new(DebugTraceTransactionResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/DebugTraceTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) StreamL2Updates(ctx context.Context, in *StreamL2UpdatesRequest, opts ...grpc.CallOption) (EnclaveProto_StreamL2UpdatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &EnclaveProto_ServiceDesc.Streams[0], "/generated.EnclaveProto/StreamL2Updates", opts...)
	if err != nil {
		return nil, err
	}
	x := &enclaveProtoStreamL2UpdatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EnclaveProto_StreamL2UpdatesClient interface {
	Recv() (*EncodedUpdateResponse, error)
	grpc.ClientStream
}

type enclaveProtoStreamL2UpdatesClient struct {
	grpc.ClientStream
}

func (x *enclaveProtoStreamL2UpdatesClient) Recv() (*EncodedUpdateResponse, error) {
	m := new(EncodedUpdateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *enclaveProtoClient) GetTotalContractCount(ctx context.Context, in *GetTotalContractCountRequest, opts ...grpc.CallOption) (*GetTotalContractCountResponse, error) {
	out := new(GetTotalContractCountResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/GetTotalContractCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) EnclavePublicConfig(ctx context.Context, in *EnclavePublicConfigRequest, opts ...grpc.CallOption) (*EnclavePublicConfigResponse, error) {
	out := new(EnclavePublicConfigResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/EnclavePublicConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveProtoClient) MakeActive(ctx context.Context, in *MakeActiveRequest, opts ...grpc.CallOption) (*MakeActiveResponse, error) {
	out := new(MakeActiveResponse)
	err := c.cc.Invoke(ctx, "/generated.EnclaveProto/MakeActive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EnclaveProtoServer is the server API for EnclaveProto service.
// All implementations must embed UnimplementedEnclaveProtoServer
// for forward compatibility
type EnclaveProtoServer interface {
	Status(context.Context, *StatusRequest) (*StatusResponse, error)
	Attestation(context.Context, *AttestationRequest) (*AttestationResponse, error)
	GenerateSecret(context.Context, *GenerateSecretRequest) (*GenerateSecretResponse, error)
	InitEnclave(context.Context, *InitEnclaveRequest) (*InitEnclaveResponse, error)
	EnclaveID(context.Context, *EnclaveIDRequest) (*EnclaveIDResponse, error)
	RPCEncryptionKey(context.Context, *RPCEncryptionKeyRequest) (*RPCEncryptionKeyResponse, error)
	SubmitL1Block(context.Context, *SubmitBlockRequest) (*SubmitBlockResponse, error)
	EncryptedRPC(context.Context, *EncCallRequest) (*EncCallResponse, error)
	SubmitBatch(context.Context, *SubmitBatchRequest) (*SubmitBatchResponse, error)
	Stop(context.Context, *StopRequest) (*StopResponse, error)
	GetCode(context.Context, *GetCodeRequest) (*GetCodeResponse, error)
	Subscribe(context.Context, *SubscribeRequest) (*SubscribeResponse, error)
	Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error)
	HealthCheck(context.Context, *EmptyArgs) (*HealthCheckResponse, error)
	GetBatch(context.Context, *GetBatchRequest) (*GetBatchResponse, error)
	GetBatchBySeqNo(context.Context, *GetBatchBySeqNoRequest) (*GetBatchResponse, error)
	GetRollupData(context.Context, *GetRollupDataRequest) (*GetRollupDataResponse, error)
	CreateBatch(context.Context, *CreateBatchRequest) (*CreateBatchResponse, error)
	CreateRollup(context.Context, *CreateRollupRequest) (*CreateRollupResponse, error)
	ExportCrossChainData(context.Context, *ExportCrossChainDataRequest) (*ExportCrossChainDataResponse, error)
	DebugTraceTransaction(context.Context, *DebugTraceTransactionRequest) (*DebugTraceTransactionResponse, error)
	StreamL2Updates(*StreamL2UpdatesRequest, EnclaveProto_StreamL2UpdatesServer) error
	GetTotalContractCount(context.Context, *GetTotalContractCountRequest) (*GetTotalContractCountResponse, error)
	EnclavePublicConfig(context.Context, *EnclavePublicConfigRequest) (*EnclavePublicConfigResponse, error)
	MakeActive(context.Context, *MakeActiveRequest) (*MakeActiveResponse, error)
	mustEmbedUnimplementedEnclaveProtoServer()
}

// UnimplementedEnclaveProtoServer must be embedded to have forward compatible implementations.
type UnimplementedEnclaveProtoServer struct {
}

func (UnimplementedEnclaveProtoServer) Status(context.Context, *StatusRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedEnclaveProtoServer) Attestation(context.Context, *AttestationRequest) (*AttestationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Attestation not implemented")
}
func (UnimplementedEnclaveProtoServer) GenerateSecret(context.Context, *GenerateSecretRequest) (*GenerateSecretResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateSecret not implemented")
}
func (UnimplementedEnclaveProtoServer) InitEnclave(context.Context, *InitEnclaveRequest) (*InitEnclaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitEnclave not implemented")
}
func (UnimplementedEnclaveProtoServer) EnclaveID(context.Context, *EnclaveIDRequest) (*EnclaveIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnclaveID not implemented")
}
func (UnimplementedEnclaveProtoServer) RPCEncryptionKey(context.Context, *RPCEncryptionKeyRequest) (*RPCEncryptionKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RPCEncryptionKey not implemented")
}
func (UnimplementedEnclaveProtoServer) SubmitL1Block(context.Context, *SubmitBlockRequest) (*SubmitBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitL1Block not implemented")
}
func (UnimplementedEnclaveProtoServer) EncryptedRPC(context.Context, *EncCallRequest) (*EncCallResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptedRPC not implemented")
}
func (UnimplementedEnclaveProtoServer) SubmitBatch(context.Context, *SubmitBatchRequest) (*SubmitBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitBatch not implemented")
}
func (UnimplementedEnclaveProtoServer) Stop(context.Context, *StopRequest) (*StopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (UnimplementedEnclaveProtoServer) GetCode(context.Context, *GetCodeRequest) (*GetCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCode not implemented")
}
func (UnimplementedEnclaveProtoServer) Subscribe(context.Context, *SubscribeRequest) (*SubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedEnclaveProtoServer) Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unsubscribe not implemented")
}
func (UnimplementedEnclaveProtoServer) HealthCheck(context.Context, *EmptyArgs) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedEnclaveProtoServer) GetBatch(context.Context, *GetBatchRequest) (*GetBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBatch not implemented")
}
func (UnimplementedEnclaveProtoServer) GetBatchBySeqNo(context.Context, *GetBatchBySeqNoRequest) (*GetBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBatchBySeqNo not implemented")
}
func (UnimplementedEnclaveProtoServer) GetRollupData(context.Context, *GetRollupDataRequest) (*GetRollupDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRollupData not implemented")
}
func (UnimplementedEnclaveProtoServer) CreateBatch(context.Context, *CreateBatchRequest) (*CreateBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBatch not implemented")
}
func (UnimplementedEnclaveProtoServer) CreateRollup(context.Context, *CreateRollupRequest) (*CreateRollupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRollup not implemented")
}
func (UnimplementedEnclaveProtoServer) ExportCrossChainData(context.Context, *ExportCrossChainDataRequest) (*ExportCrossChainDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportCrossChainData not implemented")
}
func (UnimplementedEnclaveProtoServer) DebugTraceTransaction(context.Context, *DebugTraceTransactionRequest) (*DebugTraceTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DebugTraceTransaction not implemented")
}
func (UnimplementedEnclaveProtoServer) StreamL2Updates(*StreamL2UpdatesRequest, EnclaveProto_StreamL2UpdatesServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamL2Updates not implemented")
}
func (UnimplementedEnclaveProtoServer) GetTotalContractCount(context.Context, *GetTotalContractCountRequest) (*GetTotalContractCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTotalContractCount not implemented")
}
func (UnimplementedEnclaveProtoServer) EnclavePublicConfig(context.Context, *EnclavePublicConfigRequest) (*EnclavePublicConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnclavePublicConfig not implemented")
}
func (UnimplementedEnclaveProtoServer) MakeActive(context.Context, *MakeActiveRequest) (*MakeActiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakeActive not implemented")
}
func (UnimplementedEnclaveProtoServer) mustEmbedUnimplementedEnclaveProtoServer() {}

// UnsafeEnclaveProtoServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EnclaveProtoServer will
// result in compilation errors.
type UnsafeEnclaveProtoServer interface {
	mustEmbedUnimplementedEnclaveProtoServer()
}

func RegisterEnclaveProtoServer(s grpc.ServiceRegistrar, srv EnclaveProtoServer) {
	s.RegisterService(&EnclaveProto_ServiceDesc, srv)
}

func _EnclaveProto_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).Status(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_Attestation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttestationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).Attestation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/Attestation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).Attestation(ctx, req.(*AttestationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GenerateSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GenerateSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/GenerateSecret",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GenerateSecret(ctx, req.(*GenerateSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_InitEnclave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitEnclaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).InitEnclave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/InitEnclave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).InitEnclave(ctx, req.(*InitEnclaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_EnclaveID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnclaveIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).EnclaveID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/EnclaveID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).EnclaveID(ctx, req.(*EnclaveIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_RPCEncryptionKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCEncryptionKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).RPCEncryptionKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/RPCEncryptionKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).RPCEncryptionKey(ctx, req.(*RPCEncryptionKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_SubmitL1Block_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).SubmitL1Block(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/SubmitL1Block",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).SubmitL1Block(ctx, req.(*SubmitBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_EncryptedRPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncCallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).EncryptedRPC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/EncryptedRPC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).EncryptedRPC(ctx, req.(*EncCallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_SubmitBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).SubmitBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/SubmitBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).SubmitBatch(ctx, req.(*SubmitBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).Stop(ctx, req.(*StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/GetCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetCode(ctx, req.(*GetCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/Subscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).Subscribe(ctx, req.(*SubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).Unsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/Unsubscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).Unsubscribe(ctx, req.(*UnsubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/HealthCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).HealthCheck(ctx, req.(*EmptyArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/GetBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetBatch(ctx, req.(*GetBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetBatchBySeqNo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBatchBySeqNoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetBatchBySeqNo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/GetBatchBySeqNo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetBatchBySeqNo(ctx, req.(*GetBatchBySeqNoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_GetRollupData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRollupDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetRollupData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/GetRollupData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetRollupData(ctx, req.(*GetRollupDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_CreateBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).CreateBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/CreateBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).CreateBatch(ctx, req.(*CreateBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_CreateRollup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRollupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).CreateRollup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/CreateRollup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).CreateRollup(ctx, req.(*CreateRollupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_ExportCrossChainData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportCrossChainDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).ExportCrossChainData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/ExportCrossChainData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).ExportCrossChainData(ctx, req.(*ExportCrossChainDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_DebugTraceTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DebugTraceTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).DebugTraceTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/DebugTraceTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).DebugTraceTransaction(ctx, req.(*DebugTraceTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_StreamL2Updates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamL2UpdatesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EnclaveProtoServer).StreamL2Updates(m, &enclaveProtoStreamL2UpdatesServer{stream})
}

type EnclaveProto_StreamL2UpdatesServer interface {
	Send(*EncodedUpdateResponse) error
	grpc.ServerStream
}

type enclaveProtoStreamL2UpdatesServer struct {
	grpc.ServerStream
}

func (x *enclaveProtoStreamL2UpdatesServer) Send(m *EncodedUpdateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _EnclaveProto_GetTotalContractCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTotalContractCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).GetTotalContractCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/GetTotalContractCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).GetTotalContractCount(ctx, req.(*GetTotalContractCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_EnclavePublicConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnclavePublicConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).EnclavePublicConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/EnclavePublicConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).EnclavePublicConfig(ctx, req.(*EnclavePublicConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveProto_MakeActive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MakeActiveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveProtoServer).MakeActive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/generated.EnclaveProto/MakeActive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveProtoServer).MakeActive(ctx, req.(*MakeActiveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EnclaveProto_ServiceDesc is the grpc.ServiceDesc for EnclaveProto service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EnclaveProto_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "generated.EnclaveProto",
	HandlerType: (*EnclaveProtoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _EnclaveProto_Status_Handler,
		},
		{
			MethodName: "Attestation",
			Handler:    _EnclaveProto_Attestation_Handler,
		},
		{
			MethodName: "GenerateSecret",
			Handler:    _EnclaveProto_GenerateSecret_Handler,
		},
		{
			MethodName: "InitEnclave",
			Handler:    _EnclaveProto_InitEnclave_Handler,
		},
		{
			MethodName: "EnclaveID",
			Handler:    _EnclaveProto_EnclaveID_Handler,
		},
		{
			MethodName: "RPCEncryptionKey",
			Handler:    _EnclaveProto_RPCEncryptionKey_Handler,
		},
		{
			MethodName: "SubmitL1Block",
			Handler:    _EnclaveProto_SubmitL1Block_Handler,
		},
		{
			MethodName: "EncryptedRPC",
			Handler:    _EnclaveProto_EncryptedRPC_Handler,
		},
		{
			MethodName: "SubmitBatch",
			Handler:    _EnclaveProto_SubmitBatch_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _EnclaveProto_Stop_Handler,
		},
		{
			MethodName: "GetCode",
			Handler:    _EnclaveProto_GetCode_Handler,
		},
		{
			MethodName: "Subscribe",
			Handler:    _EnclaveProto_Subscribe_Handler,
		},
		{
			MethodName: "Unsubscribe",
			Handler:    _EnclaveProto_Unsubscribe_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _EnclaveProto_HealthCheck_Handler,
		},
		{
			MethodName: "GetBatch",
			Handler:    _EnclaveProto_GetBatch_Handler,
		},
		{
			MethodName: "GetBatchBySeqNo",
			Handler:    _EnclaveProto_GetBatchBySeqNo_Handler,
		},
		{
			MethodName: "GetRollupData",
			Handler:    _EnclaveProto_GetRollupData_Handler,
		},
		{
			MethodName: "CreateBatch",
			Handler:    _EnclaveProto_CreateBatch_Handler,
		},
		{
			MethodName: "CreateRollup",
			Handler:    _EnclaveProto_CreateRollup_Handler,
		},
		{
			MethodName: "ExportCrossChainData",
			Handler:    _EnclaveProto_ExportCrossChainData_Handler,
		},
		{
			MethodName: "DebugTraceTransaction",
			Handler:    _EnclaveProto_DebugTraceTransaction_Handler,
		},
		{
			MethodName: "GetTotalContractCount",
			Handler:    _EnclaveProto_GetTotalContractCount_Handler,
		},
		{
			MethodName: "EnclavePublicConfig",
			Handler:    _EnclaveProto_EnclavePublicConfig_Handler,
		},
		{
			MethodName: "MakeActive",
			Handler:    _EnclaveProto_MakeActive_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamL2Updates",
			Handler:       _EnclaveProto_StreamL2Updates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "enclave.proto",
}
