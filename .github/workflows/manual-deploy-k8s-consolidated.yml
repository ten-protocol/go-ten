name: '[M] k8s Deploy Consolidated'
run-name: '[M] Deploy ${{ github.event.inputs.testnet_type }} (${{ github.event.inputs.deployment_strategy }})'

on:
  workflow_dispatch:
    inputs:
      testnet_type:
        description: 'Target Environment'
        required: true
        type: choice
        options:
          - 'dev-testnet'
          - 'uat-testnet'
          - 'sepolia-testnet'
          - 'mainnet'

      deployment_strategy:
        description: 'Deployment Strategy'
        required: true
        type: choice
        options:
          - 'non-destructive'
          - 'destructive'

      image_build:
        description: 'Build & Push Images'
        required: true
        type: choice
        options:
          - 'yes'
          - 'no'

      image_tag:
        description: 'Image Tag (e.g., v1.5.8.0 or leave empty for auto: git tag or commit hash)'
        required: false
        type: string

      confirmation:
        description: 'Type "confirm" if deploying sepolia or mainnet'
        required: false
        type: string

      advanced_config:
        description: 'Advanced options (format: log_level=3,max_gas_gwei=1.5,sync_timeout=10m,use_azure_hsm=no)'
        required: false
        type: string
        default: 'log_level=3,max_gas_gwei=1.5,sync_timeout=10m,use_azure_hsm=no'

      skip_steps:
        description: 'Skip specific steps for testing (comma-separated: l1-deployment, l2-trigger, image-build, config-update, argocd-delete)'
        required: false
        type: string
        default: ''

      destructive_options:
        description: 'Destructive deployment options (format: node_selectors=sequencer=node1,validator-01=node2,validator-02=node3,gateway=node4|additional_apps=gateway,tools,postgres-client)'
        required: false
        type: string

concurrency:
  group: ${{ github.event.inputs.testnet_type }}-deployment
  cancel-in-progress: true

env:
  REGISTRY: testnetobscuronet.azurecr.io
  REGISTRY_ORG: obscuronet

jobs:
  # ============================================================================
  # VALIDATION & SETUP
  # ============================================================================
  validate-inputs:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'  # Only run on manual triggers
    outputs:
      TESTNET_SHORT_NAME: ${{ steps.setup.outputs.TESTNET_SHORT_NAME }}
      IS_DESTRUCTIVE: ${{ steps.setup.outputs.IS_DESTRUCTIVE }}
      NEEDS_APPROVAL: ${{ steps.setup.outputs.NEEDS_APPROVAL }}
      CONFIG_PATH: ${{ steps.setup.outputs.CONFIG_PATH }}
      CHILD_APPS: ${{ steps.setup.outputs.CHILD_APPS }}
      ADDITIONAL_APPS_TO_DELETE: ${{ steps.setup.outputs.ADDITIONAL_APPS_TO_DELETE }}

    steps:
      - name: 'Check confirmation for production envs'
        run: |
          if [[ ("${{ github.event.inputs.testnet_type }}" == "sepolia-testnet" || "${{ github.event.inputs.testnet_type }}" == "mainnet") && "${{ github.event.inputs.confirmation }}" != "confirm" ]]; then
            echo "❌ Confirmation field must say 'confirm' to deploy to sepolia or mainnet"
            exit 1
          fi

      - name: 'Setup environment variables'
        id: setup
        run: |
          TESTNET_TYPE="${{ github.event.inputs.testnet_type }}"

          # Extract short name
          if [[ "$TESTNET_TYPE" == "mainnet" ]]; then
            SHORT_NAME="mainnet"
          else
            SHORT_NAME=${TESTNET_TYPE%-testnet}
          fi
          echo "TESTNET_SHORT_NAME=$SHORT_NAME" >> $GITHUB_OUTPUT

          # Determine config path
          if [[ "$TESTNET_TYPE" == "mainnet" ]]; then
            CONFIG_PATH="prod-argocd-config"
          else
            CONFIG_PATH="nonprod-argocd-config"
          fi
          echo "CONFIG_PATH=$CONFIG_PATH" >> $GITHUB_OUTPUT

          # Check if destructive
          if [[ "${{ github.event.inputs.deployment_strategy }}" == "destructive" ]]; then
            echo "IS_DESTRUCTIVE=true" >> $GITHUB_OUTPUT
          else
            echo "IS_DESTRUCTIVE=false" >> $GITHUB_OUTPUT
          fi

          # Check if approval needed (destructive + sepolia/mainnet)
          if [[ "${{ github.event.inputs.deployment_strategy }}" == "destructive" && ("$TESTNET_TYPE" == "sepolia-testnet" || "$TESTNET_TYPE" == "mainnet") ]]; then
            echo "NEEDS_APPROVAL=true" >> $GITHUB_OUTPUT
          else
            echo "NEEDS_APPROVAL=false" >> $GITHUB_OUTPUT
          fi

          # Set child apps per environment (for syncing)
          case "$TESTNET_TYPE" in
            dev-testnet)
              echo "CHILD_APPS=dev-sequencer dev-validator-01 dev-validator-02 dev-gateway dev-ten-tools" >> $GITHUB_OUTPUT
              ;;
            uat-testnet)
              echo "CHILD_APPS=uat-sequencer uat-validator-01 uat-validator-02 uat-gateway uat-ten-tools" >> $GITHUB_OUTPUT
              ;;
            sepolia-testnet)
              echo "CHILD_APPS=sepolia-sequencer sepolia-validator-01 sepolia-validator-02 sepolia-gateway sepolia-gateway-dexynth sepolia-gateway-pentest sepolia-ten-tools" >> $GITHUB_OUTPUT
              ;;
            mainnet)
              echo "CHILD_APPS=mainnet-sequencer mainnet-validator-01 mainnet-validator-02 mainnet-gateway mainnet-postgres-client mainnet-ten-tools" >> $GITHUB_OUTPUT
              ;;
          esac

          # Parse destructive_options (if provided, destructive only)
          # Format: node_selectors=sequencer=node1,validator-01=node2,validator-02=node3,gateway=node4|additional_apps=gateway,tools,postgres-client
          DESTRUCTIVE_OPTS="${{ github.event.inputs.destructive_options }}"

          # Extract additional_apps from destructive_options
          if [[ "$DESTRUCTIVE_OPTS" =~ additional_apps=([^|]*) ]]; then
            ADDITIONAL_APPS="${BASH_REMATCH[1]}"
            if [[ -n "$ADDITIONAL_APPS" ]]; then
              # Convert comma-separated to environment-prefixed list
              IFS=',' read -ra APPS <<< "$ADDITIONAL_APPS"
              PREFIXED_APPS=""
              for app in "${APPS[@]}"; do
                app=$(echo "$app" | xargs)  # trim whitespace
                prefixed_app="${SHORT_NAME}-${app}"
                PREFIXED_APPS="$PREFIXED_APPS $prefixed_app"
              done
              echo "ADDITIONAL_APPS_TO_DELETE=$PREFIXED_APPS" >> $GITHUB_OUTPUT
            else
              echo "ADDITIONAL_APPS_TO_DELETE=" >> $GITHUB_OUTPUT
            fi
          else
            echo "ADDITIONAL_APPS_TO_DELETE=" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # APPROVAL (mandatory for sepolia/mainnet, skipped for dev/uat)
  # Runs right after validation to show summary and request approval early
  # ============================================================================
  approval:
    needs: [validate-inputs]
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - uses: actions/checkout@v4

      - name: 'Determine image tag'
        id: get_tag
        run: |
          # Use provided tag, or git tag, or commit hash
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          else
            # Try git tag first, fall back to short commit hash
            IMAGE_TAG=$(git describe --tags --exact-match 2>/dev/null || git rev-parse --short HEAD)
          fi
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: 'Show deployment summary and request approval'
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "🚨 DEPLOYMENT APPROVAL REQUIRED"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "📋 Deployment Summary:"
          echo "  Environment:         ${{ github.event.inputs.testnet_type }}"
          echo "  Strategy:            ${{ github.event.inputs.deployment_strategy }}"
          echo "  Triggered by:        ${{ github.actor }}"
          echo "  Branch:              ${{ github.ref_name }}"
          echo ""
          if [[ "${{ github.event.inputs.image_build }}" == "yes" ]]; then
            echo "🐳 Image Build:       ✅ Will be built"
            echo "  Image Tag:          ${{ steps.get_tag.outputs.IMAGE_TAG }}"
          else
            echo "🐳 Image Build:       ⏭️  Skipped (using existing images)"
            echo "  Current Tag:        ${{ steps.get_tag.outputs.IMAGE_TAG }}"
          fi
          echo ""
          if [[ "${{ github.event.inputs.deployment_strategy }}" == "destructive" ]]; then
            echo "🔥 DESTRUCTIVE Deployment Actions:"
            echo "  1. Build & push images (if enabled)"
            echo "  2. Update ten-apps config"
            echo "  3. Deploy L1 contracts"
            echo "  4. Delete child apps (sequencer, validators)"
            echo "  5. Sync parent app (recreates children)"
            echo "  6. Sync all ArgoCD apps"
            echo "  7. Wait for apps to be healthy"
            echo "  8. Auto-trigger L2 deployment"
            echo ""
            echo "⚠️  WARNING: This will cause downtime!"
          else
            echo "📦 NON-DESTRUCTIVE Deployment Actions:"
            echo "  1. Build & push images (if enabled)"
            echo "  2. Update ten-apps config"
            echo "  3. Delete host deployment and enclave statefulsets"
            echo "  4. Sync ONLY OutOfSync resources (no sync waves/hooks)"
            echo "  5. Wait for apps to be healthy"
            echo ""
            echo "✅ No L1/L2 contract deployment (minimal disruption)"
          fi
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Please review and approve to continue"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  # ============================================================================
  # REVERT CONFIG IF APPROVAL REJECTED
  # ============================================================================
  revert-config-on-rejection:
    needs: [validate-inputs, approval, build-images, update-ten-apps-config]
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.validate-inputs.outputs.NEEDS_APPROVAL == 'true' &&
      needs.update-ten-apps-config.result == 'success' &&
      needs.approval.result == 'failure'
    steps:
      - uses: actions/checkout@v4
        with:
          repository: ten-protocol/ten-apps
          token: ${{ secrets.DEPLOY_ACTIONS_PAT }}
          path: ten-apps
          fetch-depth: 2

      - name: 'Revert ten-apps config changes'
        env:
          IMAGE_TAG: ${{ needs.build-images.outputs.IMAGE_TAG }}
        run: |
          cd ten-apps
          
          echo "❌ Approval was rejected - reverting ten-apps config changes"
          echo "Image tag that was set: ${IMAGE_TAG}"
          
          # Revert the last commit
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git revert --no-edit HEAD
          git push
          
          echo "✅ Reverted config changes in ten-apps"
          echo "⚠️  Note: Docker images were already built and pushed (not reverted)"

  # ============================================================================
  # BUILD & PUSH IMAGES (Optional)
  # ============================================================================
  build-images:
    needs: [validate-inputs]
    if: |
      github.event.inputs.image_build == 'yes' &&
      !contains(github.event.inputs.skip_steps, 'image-build')
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    outputs:
      IMAGE_TAG: ${{ steps.get_tag.outputs.IMAGE_TAG }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: 1.25.1

      - name: 'Parse advanced config'
        id: parse_config
        run: |
          ADVANCED_CONFIG="${{ github.event.inputs.advanced_config }}"
          USE_HSM="no"
          [[ "$ADVANCED_CONFIG" =~ use_azure_hsm=([^ ,]+) ]] && USE_HSM="${BASH_REMATCH[1]}"
          echo "USE_HSM=$USE_HSM" >> $GITHUB_OUTPUT

      - name: 'Login via Azure CLI (for HSM)'
        if: steps.parse_config.outputs.USE_HSM == 'yes'
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: 'Login to Azure docker registry'
        uses: azure/docker-login@v1
        with:
          login-server: testnetobscuronet.azurecr.io
          username: testnetobscuronet
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: 'Determine image tag'
        id: get_tag
        run: |
          # Use provided tag, or git tag, or commit hash
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          else
            # Try git tag first, fall back to short commit hash
            IMAGE_TAG=$(git describe --tags --exact-match 2>/dev/null || git rev-parse --short HEAD)
          fi
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "📦 Image tag: $IMAGE_TAG"
          echo "::set-output name=IMAGE_TAG::$IMAGE_TAG"

      - name: 'Build and push obscuro node images'
        env:
          IMAGE_TAG: ${{ steps.get_tag.outputs.IMAGE_TAG }}
          USE_HSM: ${{ steps.parse_config.outputs.USE_HSM }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: |
          set -e
          
          # Enable Docker BuildKit for better caching and parallel builds
          export DOCKER_BUILDKIT=1
          export BUILDKIT_PROGRESS=plain
          
          echo "🏗️  Building images with tag: ${IMAGE_TAG}"
          echo "Using Docker BuildKit with layer caching"
          
          # Function to build and push in background
          build_and_push() {
            local name=$1
            local dockerfile=$2
            local extra_args=$3
            
            echo "Building ${name}..."
            docker build \
              --cache-from ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/${name}:latest \
              --cache-from ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/${name}:${IMAGE_TAG} \
              -t ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/${name}:${IMAGE_TAG} \
              -f ${dockerfile} \
              ${extra_args} \
              . 2>&1 | sed "s/^/[${name}] /" &
          }
          
          # Build enclave (with optional HSM)
          if [[ "$USE_HSM" == "yes" ]]; then
            echo "🔐 Building enclave with Azure HSM..."
            build_and_push "enclave" "dockerfiles/enclave.Dockerfile" \
              "--build-arg AZURE_TENANT_ID=${AZURE_TENANT_ID} --build-arg AZURE_SUBSCRIPTION_ID=${AZURE_SUBSCRIPTION_ID}"
          else
            echo "📦 Building enclave without HSM..."
            build_and_push "enclave" "dockerfiles/enclave.Dockerfile" ""
          fi
          
          # Build host and hardhat deployer in parallel
          build_and_push "host" "dockerfiles/host.Dockerfile" ""
          build_and_push "hardhatdeployer" "tools/hardhatdeployer/Dockerfile" ""
          
          # Wait for all builds to complete
          echo "⏳ Waiting for all builds to complete..."
          wait
          
          # Check if any build failed
          if [ $? -ne 0 ]; then
            echo "❌ One or more builds failed"
            exit 1
          fi
          
          echo "✅ All builds completed successfully"
          echo ""
          echo "📤 Pushing images..."
          
          # Push all images in parallel
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/enclave:${IMAGE_TAG} &
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/host:${IMAGE_TAG} &
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/hardhatdeployer:${IMAGE_TAG} &
          
          # Wait for all pushes
          wait
          
          echo "✅ All images built and pushed with tag: ${IMAGE_TAG}"

  # ============================================================================
  # UPDATE TEN-APPS YAML WITH NEW IMAGE TAGS
  # ============================================================================
  update-ten-apps-config:
    needs: [validate-inputs, build-images]
    if: |
      (needs.build-images.result == 'success' || needs.build-images.result == 'skipped') &&
      !contains(github.event.inputs.skip_steps, 'config-update')
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - uses: actions/checkout@v4
        with:
          repository: ten-protocol/ten-apps
          token: ${{ secrets.DEPLOY_ACTIONS_PAT }}
          path: ten-apps

      - name: 'Install yq'
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.1/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - uses: actions/checkout@v4
        if: needs.build-images.result == 'skipped'

      - name: 'Determine IMAGE_TAG if not built'
        if: needs.build-images.result == 'skipped'
        id: get_tag
        run: |
          # Use provided tag, or git tag, or commit hash (same as build-images)
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          else
            IMAGE_TAG=$(git describe --tags --exact-match 2>/dev/null || git rev-parse --short HEAD)
          fi
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: 'Update image tags and node selectors in ten-apps config'
        env:
          IMAGE_TAG: ${{ needs.build-images.result == 'success' && needs.build-images.outputs.IMAGE_TAG || steps.get_tag.outputs.IMAGE_TAG }}
          CONFIG_PATH: ${{ needs.validate-inputs.outputs.CONFIG_PATH }}
          DESTRUCTIVE_OPTIONS_INPUT: ${{ github.event.inputs.destructive_options }}
          IS_DESTRUCTIVE: ${{ needs.validate-inputs.outputs.IS_DESTRUCTIVE }}
        run: |
          cd ten-apps

          # Determine the config directory
          if [[ "${{ github.event.inputs.testnet_type }}" == "mainnet" ]]; then
            ENV_DIR="${{ env.CONFIG_PATH }}/apps/envs/mainnet/valuesFile"
          else
            ENV_DIR="${{ env.CONFIG_PATH }}/apps/envs/${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}/valuesFile"
          fi

          echo "📝 Updating image tags to: ${IMAGE_TAG} in $ENV_DIR"

          # Update all values files with new image tags (host and enclave only)
          for values_file in "$ENV_DIR"/values-*.yaml; do
            if [ -f "$values_file" ]; then
              filename=$(basename "$values_file")
              echo "  Updating $filename..."

              # Update image tags for host and enclave only
              yq eval -i ".enclave.image.tag = \"${IMAGE_TAG}\"" "$values_file" 2>/dev/null || true
              yq eval -i ".enclave02.image.tag = \"${IMAGE_TAG}\"" "$values_file" 2>/dev/null || true
              yq eval -i ".host.image.tag = \"${IMAGE_TAG}\"" "$values_file" 2>/dev/null || true
            fi
          done

          echo "✅ Image tags updated"

          # ⚠️  NODE SELECTORS ONLY FOR DESTRUCTIVE DEPLOYMENTS
          # Extract node_selectors from destructive_options
          NODE_SELECTORS_INPUT=""
          if [[ "${{ env.DESTRUCTIVE_OPTIONS_INPUT }}" =~ node_selectors=([^|]*) ]]; then
            NODE_SELECTORS_INPUT="${BASH_REMATCH[1]}"
          fi

          if [[ "${{ env.IS_DESTRUCTIVE }}" == "true" ]] && [[ -n "$NODE_SELECTORS_INPUT" ]]; then
            echo "🔥 DESTRUCTIVE deployment: Parsing and applying node selectors"

            # Parse node_selectors input (format: sequencer=node1,validator-01=node2,validator-02=node3,gateway=node4)
            declare -A node_selectors
            IFS=',' read -ra pairs <<< "$NODE_SELECTORS_INPUT"
            for pair in "${pairs[@]}"; do
              key="${pair%%=*}"
              value="${pair##*=}"
              node_selectors["$key"]="$value"
            done

            # Update sequencer node selector (if provided)
            if [[ -n "${node_selectors[sequencer]}" ]]; then
              echo "📍 Updating sequencer node selector to: ${node_selectors[sequencer]}"
              seq_file="$ENV_DIR/values-${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}-sequencer.yaml"
              if [ -f "$seq_file" ]; then
                yq eval -i ".enclave.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[sequencer]}\"" "$seq_file"
                yq eval -i ".enclave02.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[sequencer]}\"" "$seq_file" 2>/dev/null || true
                yq eval -i ".host.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[sequencer]}\"" "$seq_file"
                echo "✅ Sequencer node selector updated"
              fi
            fi

            # Update validator-01 node selector (if provided)
            if [[ -n "${node_selectors[validator-01]}" ]]; then
              echo "📍 Updating validator-01 node selector to: ${node_selectors[validator-01]}"
              val1_file="$ENV_DIR/values-${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}-validator-01.yaml"
              if [ -f "$val1_file" ]; then
                yq eval -i ".enclave.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[validator-01]}\"" "$val1_file"
                yq eval -i ".enclave02.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[validator-01]}\"" "$val1_file" 2>/dev/null || true
                yq eval -i ".host.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[validator-01]}\"" "$val1_file"
                echo "✅ Validator-01 node selector updated"
              fi
            fi

            # Update validator-02 node selector (if provided)
            if [[ -n "${node_selectors[validator-02]}" ]]; then
              echo "📍 Updating validator-02 node selector to: ${node_selectors[validator-02]}"
              val2_file="$ENV_DIR/values-${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}-validator-02.yaml"
              if [ -f "$val2_file" ]; then
                yq eval -i ".enclave.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[validator-02]}\"" "$val2_file"
                yq eval -i ".enclave02.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[validator-02]}\"" "$val2_file" 2>/dev/null || true
                yq eval -i ".host.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[validator-02]}\"" "$val2_file"
                echo "✅ Validator-02 node selector updated"
              fi
            fi

            # Update gateway node selector (if provided)
            if [[ -n "${node_selectors[gateway]}" ]]; then
              echo "📍 Updating gateway node selector to: ${node_selectors[gateway]}"
              gw_file="$ENV_DIR/values-${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}-gateway.yaml"
              if [ -f "$gw_file" ]; then
                yq eval -i ".gateway.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[gateway]}\"" "$gw_file"
                echo "✅ Gateway node selector updated"
              fi
            fi
          elif [[ "${{ env.IS_DESTRUCTIVE }}" != "true" ]]; then
            echo "📌 NON-DESTRUCTIVE deployment: Skipping node selector updates"
          else
            echo "ℹ️  No node selectors provided"
          fi

          # Commit changes
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add "$ENV_DIR/values-*.yaml"

          if git diff --cached --quiet; then
            echo "ℹ️  No changes to commit"
          else
            commit_msg="chore: update "
            [[ "${{ env.IMAGE_TAG }}" != "" ]] && commit_msg+="image tags to ${{ env.IMAGE_TAG }}"

            if [[ "${{ env.IS_DESTRUCTIVE }}" == "true" ]] && [[ -n "$NODE_SELECTORS_INPUT" ]]; then
              [[ "${{ env.IMAGE_TAG }}" != "" ]] && commit_msg+=" and "
              commit_msg+="node selectors"
            fi

            commit_msg+=" for ${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}"

            git commit -m "$commit_msg"
            git push
            echo "✅ Updated and pushed changes to ten-apps"
          fi

  # ============================================================================
  # DEPLOY L1 CONTRACTS (Destructive only)
  # ============================================================================
  deploy-l1-contracts:
    needs: [validate-inputs, approval, update-ten-apps-config]
    if: |
      needs.validate-inputs.outputs.IS_DESTRUCTIVE == 'true' &&
      !contains(github.event.inputs.skip_steps, 'l1-deployment')
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    outputs:
      NETWORK_CONFIG_ADDR: ${{ steps.deploy.outputs.NETWORK_CONFIG_ADDR }}
      MSG_BUS_CONTRACT_ADDR: ${{ steps.deploy.outputs.MSG_BUS_CONTRACT_ADDR }}
      BRIDGE_CONTRACT_ADDR: ${{ steps.deploy.outputs.BRIDGE_CONTRACT_ADDR }}
      CROSS_CHAIN_ADDR: ${{ steps.deploy.outputs.CROSS_CHAIN_ADDR }}
      DA_REGISTRY_ADDR: ${{ steps.deploy.outputs.DA_REGISTRY_ADDR }}
      ENCLAVE_REGISTRY_ADDR: ${{ steps.deploy.outputs.ENCLAVE_REGISTRY_ADDR }}
      L1_START_HASH: ${{ steps.deploy.outputs.L1_START_HASH }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: 1.25.1

      - name: 'Login via Azure CLI'
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: 'Login to Azure docker registry'
        uses: azure/docker-login@v1
        with:
          login-server: ${{ env.REGISTRY }}
          username: testnetobscuronet
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: 'Parse advanced config'
        id: parse_config
        run: |
          ADVANCED_CONFIG="${{ github.event.inputs.advanced_config }}"
          MAX_GAS_GWEI="1.5"
          [[ "$ADVANCED_CONFIG" =~ max_gas_gwei=([^ ,]+) ]] && MAX_GAS_GWEI="${BASH_REMATCH[1]}"
          echo "MAX_GAS_GWEI=$MAX_GAS_GWEI" >> $GITHUB_OUTPUT

      - name: 'Deploy Contracts'
        id: deployContracts
        shell: bash
        env:
          DOCKER_API_VERSION: "1.45"
          DEPLOY_DOCKERIMAGE: ${{ vars.DOCKER_BUILD_TAG_L2_HARDHAT_DEPLOYER }}
          DEPLOY_NETWORKNAME: ${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}
          DEPLOY_GITHUBPAT: ${{ secrets.DEPLOY_ACTIONS_PAT }}
          DEPLOY_OUTPUTENV: ./testnet/.env
          DEPLOY_L1_RPCADDRESS: ${{ secrets.L1_HTTP_URL }}
          DEPLOY_L1_DEPLOYERPK: ${{ secrets.ACCOUNT_PK_WORKER }}
          DEPLOY_L1_INITIALSEQADDRESS: ${{ vars.ACCOUNT_ADDR_NODE_0 }}
          DEPLOY_L1_ETHERSCANAPIKEY: ${{ secrets.ETHERSCAN_API_KEY }}
          DEPLOY_L1_MAXGASGWEI: ${{ steps.parse_config.outputs.MAX_GAS_GWEI }}
          DEPLOY_L1_CHECKGASPRICE: ${{ github.event.inputs.testnet_type == 'mainnet' && 'true' || 'false' }}
        run: |
          # Run deployer and capture output
          go run ./testnet/launcher/l1contractdeployer/cmd
          
          if [ -f ./testnet/.env ]; then
            source ./testnet/.env
          fi          
          # Fix variable names and GITHUB_OUTPUT reference
          echo "NETWORK_CONFIG_ADDR=$NETWORKCONFIGADDR" >> $GITHUB_ENV
          echo "NETWORK_CONFIG_ADDR=$NETWORKCONFIGADDR" >> $GITHUB_OUTPUT
          
          echo "MSG_BUS_CONTRACT_ADDR=$MSGBUSCONTRACTADDR" >> $GITHUB_ENV
          echo "MSG_BUS_CONTRACT_ADDR=$MSGBUSCONTRACTADDR" >> $GITHUB_OUTPUT
          
          echo "BRIDGE_CONTRACT_ADDR=$BRIDGECONTRACTADDR" >> $GITHUB_ENV
          echo "BRIDGE_CONTRACT_ADDR=$BRIDGECONTRACTADDR" >> $GITHUB_OUTPUT
          
          echo "CROSS_CHAIN_ADDR=$CROSSCHAINADDR" >> $GITHUB_ENV
          echo "CROSS_CHAIN_ADDR=$CROSSCHAINADDR" >> $GITHUB_OUTPUT
          
          echo "DA_REGISTRY_ADDR=$DAREGISTRYADDR" >> $GITHUB_ENV
          echo "DA_REGISTRY_ADDR=$DAREGISTRYADDR" >> $GITHUB_OUTPUT
          
          echo "ENCLAVE_REGISTRY_ADDR=$ENCLAVEREGISTRYADDR" >> $GITHUB_ENV
          echo "ENCLAVE_REGISTRY_ADDR=$ENCLAVEREGISTRYADDR" >> $GITHUB_OUTPUT
          
          echo "L1_START_HASH=$L1START" >> $GITHUB_ENV
          echo "L1_START_HASH=$L1START" >> $GITHUB_OUTPUT

      - name: 'Save L1 deployer container logs'
        # Wait to make sure the logs are available in the container
        if: ${{ always() }} # Always run this step to ensure logs are captured even if previous steps fail
        run: |
          sleep 60
          docker logs `docker ps -aqf "name=hh-l1-deployer"` > deploy-l1-contracts.out 2>&1
          
      - name: 'Upload L1 deployer container logs'
        if: ${{ always() }} # Always run this step to ensure logs are uploaded even if previous steps fail
        uses: actions/upload-artifact@v4
        with:
          name: deploy-l1-artifacts
          path: |
            deploy-l1-contracts.out
          retention-days: 2

  # ============================================================================
  # ARGOCD - DELETE CHILD APPS (Destructive only)
  # ============================================================================
  argocd-delete-child-apps:
    needs: [validate-inputs, approval, deploy-l1-contracts]
    if: |
      needs.validate-inputs.outputs.IS_DESTRUCTIVE == 'true' &&
      (needs.deploy-l1-contracts.result == 'success' || needs.deploy-l1-contracts.result == 'skipped') &&
      !contains(github.event.inputs.skip_steps, 'argocd-delete')
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - name: 'Install ArgoCD CLI'
        run: |
          curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x /usr/local/bin/argocd

      - name: 'Login to ArgoCD'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_USERNAME: ${{ secrets.ARGOCD_USERNAME }}
          ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
        run: |
          set -e
          
          echo "🔐 Logging in to ArgoCD server: ${ARGOCD_SERVER}"
          
          if [[ -z "${ARGOCD_SERVER}" ]] || [[ -z "${ARGOCD_USERNAME}" ]] || [[ -z "${ARGOCD_PASSWORD}" ]]; then
            echo "❌ ERROR: ArgoCD credentials not set!"
            exit 1
          fi
          
          argocd login "${ARGOCD_SERVER}" \
            --username "${ARGOCD_USERNAME}" \
            --password "${ARGOCD_PASSWORD}" \
            --insecure
          
          echo "✅ Successfully logged in to ArgoCD"

      - name: 'Delete ArgoCD child applications and sync parent'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          DEFAULT_APPS: "sequencer validator-01 validator-02"
          ADDITIONAL_APPS: ${{ needs.validate-inputs.outputs.ADDITIONAL_APPS_TO_DELETE }}
          TESTNET_SHORT_NAME: ${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}
        run: |
          set -e

          echo "🔥 DESTRUCTIVE DEPLOYMENT: Delete child apps and sync parent"
          echo "Environment: ${{ github.event.inputs.testnet_type }}"
          echo ""
          
          # Validate required variables
          if [[ -z "${ARGOCD_SERVER}" ]]; then
            echo "❌ ERROR: ARGOCD_SERVER is not set!"
            exit 1
          fi
          
          # Determine parent app name based on environment
          PARENT_APP="ten-${TESTNET_SHORT_NAME}-apps"
          echo "📌 Parent app: $PARENT_APP"
          echo ""

          # Step 1: Delete child apps
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "STEP 1: Delete child applications"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          
          # Always delete default apps (sequencer, validator-01, validator-02)
          echo "Default apps to delete: sequencer, validator-01, validator-02"
          for app_suffix in ${DEFAULT_APPS}; do
            app="${TESTNET_SHORT_NAME}-${app_suffix}"
            echo "  🗑️  Deleting: $app"
            if ! argocd app delete "$app" --server "${ARGOCD_SERVER}" --cascade --yes 2>&1 | tee /tmp/argocd_output.txt; then
              if grep -q "NotFound\|not found" /tmp/argocd_output.txt; then
                echo "     ℹ️  App not found (this is OK)"
              else
                echo "     ❌ Failed to delete app"
                exit 1
              fi
            else
              echo "     ✅ Deleted"
            fi
            sleep 2
          done

          # Delete additional apps if specified
          if [[ -n "${ADDITIONAL_APPS}" ]]; then
            echo ""
            echo "Additional apps to delete: ${ADDITIONAL_APPS}"
            for app in ${ADDITIONAL_APPS}; do
              echo "  🗑️  Deleting: $app"
              if ! argocd app delete "$app" --server "${ARGOCD_SERVER}" --cascade --yes 2>&1 | tee /tmp/argocd_output.txt; then
                if grep -q "NotFound\|not found" /tmp/argocd_output.txt; then
                  echo "     ℹ️  App not found (this is OK)"
                else
                  echo "     ❌ Failed to delete app"
                  exit 1
                fi
              else
                echo "     ✅ Deleted"
              fi
              sleep 2
            done
          fi
          
          echo ""
          echo "✅ Child apps deleted"
          echo ""
          
          # Step 2: Sync parent app to recreate child apps
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "STEP 2: Sync parent app to recreate children"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "🔄 Syncing parent app: $PARENT_APP"
          
          if argocd app sync "$PARENT_APP" --server "${ARGOCD_SERVER}" --grpc-web; then
            echo "✅ Parent app synced - child apps should be recreated"
          else
            echo "❌ Failed to sync parent app"
            exit 1
          fi
          
          echo ""
          echo "⏳ Waiting 10 seconds for child apps to be created..."
          sleep 10
          
          echo ""
          echo "✅ Destructive delete and recreate complete"
          echo "   Child apps will be fully synced in the next job"

  # ============================================================================
  # ARGOCD - DELETE DEPLOYMENTS/STS (Non-Destructive only)
  # ============================================================================
  argocd-delete-resources:
    needs: [validate-inputs, approval, update-ten-apps-config]
    if: |
      needs.validate-inputs.outputs.IS_DESTRUCTIVE == 'false' &&
      !contains(github.event.inputs.skip_steps, 'argocd-delete')
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - name: 'Install ArgoCD CLI'
        run: |
          curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x /usr/local/bin/argocd

      - name: 'Login to ArgoCD'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_USERNAME: ${{ secrets.ARGOCD_USERNAME }}
          ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
        run: |
          set -e
          
          echo "🔐 Logging in to ArgoCD server: ${ARGOCD_SERVER}"
          
          # Validate credentials are set
          if [[ -z "${ARGOCD_SERVER}" ]]; then
            echo "❌ ERROR: ARGOCD_SERVER is not set!"
            exit 1
          fi
          
          if [[ -z "${ARGOCD_USERNAME}" ]] || [[ -z "${ARGOCD_PASSWORD}" ]]; then
            echo "❌ ERROR: ARGOCD_USERNAME or ARGOCD_PASSWORD is not set!"
            exit 1
          fi
          
          # Login to ArgoCD
          argocd login "${ARGOCD_SERVER}" \
            --username "${ARGOCD_USERNAME}" \
            --password "${ARGOCD_PASSWORD}" \
            --insecure
          
          echo "✅ Successfully logged in to ArgoCD"

      - name: 'Delete host and enclave deployments/statefulsets via ArgoCD'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          TESTNET_SHORT_NAME: ${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}
        run: |
          set -e

          echo "🗑️  Non-destructive deployment: Deleting host and enclave deployments/statefulsets"
          echo "Environment: ${TESTNET_SHORT_NAME}"
          echo "ArgoCD Server: ${ARGOCD_SERVER}"
          
          # Validate required variables
          if [[ -z "${ARGOCD_SERVER}" ]]; then
            echo "❌ ERROR: ARGOCD_SERVER is not set!"
            exit 1
          fi
          
          if [[ -z "${TESTNET_SHORT_NAME}" ]]; then
            echo "❌ ERROR: TESTNET_SHORT_NAME is not set!"
            exit 1
          fi

          APPS=("sequencer" "validator-01" "validator-02")

          for app_suffix in "${APPS[@]}"; do
            app="${TESTNET_SHORT_NAME}-${app_suffix}"
            echo "Processing app: $app"

            # Delete host deployment (only ignore NotFound errors)
            echo "  Deleting host deployment..."
            if ! argocd app delete-resource "$app" \
              --server "${ARGOCD_SERVER}" \
              --kind Deployment \
              --resource-name "${app}-host" \
              --all 2>&1 | tee /tmp/argocd_output.txt; then
              if grep -q "NotFound\|not found" /tmp/argocd_output.txt; then
                echo "  ℹ️  Host deployment not found (this is OK)"
              else
                echo "  ❌ Failed to delete host deployment"
                exit 1
              fi
            fi

            # Delete enclave statefulset (only ignore NotFound errors)
            echo "  Deleting enclave statefulset..."
            if ! argocd app delete-resource "$app" \
              --server "${ARGOCD_SERVER}" \
              --kind StatefulSet \
              --resource-name "${app}-enclave" \
              --all 2>&1 | tee /tmp/argocd_output.txt; then
              if grep -q "NotFound\|not found" /tmp/argocd_output.txt; then
                echo "  ℹ️  Enclave statefulset not found (this is OK)"
              else
                echo "  ❌ Failed to delete enclave statefulset"
                exit 1
              fi
            fi

            # Delete enclave02 statefulset (only ignore NotFound errors)
            echo "  Deleting enclave02 statefulset..."
            if ! argocd app delete-resource "$app" \
              --server "${ARGOCD_SERVER}" \
              --kind StatefulSet \
              --resource-name "${app}-enclave02" \
              --all 2>&1 | tee /tmp/argocd_output.txt; then
              if grep -q "NotFound\|not found" /tmp/argocd_output.txt; then
                echo "  ℹ️  Enclave02 statefulset not found (this is OK)"
              else
                echo "  ❌ Failed to delete enclave02 statefulset"
                exit 1
              fi
            fi

            sleep 2
          done

          echo "✅ Resource deletion complete"

  # ============================================================================
  # ARGOCD - SYNC APPLICATIONS
  # ============================================================================
  argocd-sync-apps:
    needs: [validate-inputs, approval, update-ten-apps-config, deploy-l1-contracts, argocd-delete-child-apps, argocd-delete-resources]
    if: |
      (needs.argocd-delete-child-apps.result == 'success' || needs.argocd-delete-child-apps.result == 'skipped') &&
      (needs.argocd-delete-resources.result == 'success' || needs.argocd-delete-resources.result == 'skipped')
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    outputs:
      APPS_SYNCED: ${{ steps.sync.outputs.APPS_SYNCED }}

    steps:
      - name: 'Install ArgoCD CLI'
        run: |
          curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x /usr/local/bin/argocd

      - name: 'Login to ArgoCD'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_USERNAME: ${{ secrets.ARGOCD_USERNAME }}
          ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
        run: |
          set -e
          
          echo "🔐 Logging in to ArgoCD server: ${ARGOCD_SERVER}"
          
          if [[ -z "${ARGOCD_SERVER}" ]] || [[ -z "${ARGOCD_USERNAME}" ]] || [[ -z "${ARGOCD_PASSWORD}" ]]; then
            echo "❌ ERROR: ArgoCD credentials not set!"
            exit 1
          fi
          
          argocd login "${ARGOCD_SERVER}" \
            --username "${ARGOCD_USERNAME}" \
            --password "${ARGOCD_PASSWORD}" \
            --insecure
          
          echo "✅ Successfully logged in to ArgoCD"

      - name: 'Parse advanced config'
        id: parse_config
        run: |
          ADVANCED_CONFIG="${{ github.event.inputs.advanced_config }}"
          SYNC_TIMEOUT="10m"
          [[ "$ADVANCED_CONFIG" =~ sync_timeout=([^ ,]+) ]] && SYNC_TIMEOUT="${BASH_REMATCH[1]}"
          echo "SYNC_TIMEOUT=$SYNC_TIMEOUT" >> $GITHUB_OUTPUT

      - name: 'Sync ArgoCD child applications'
        id: sync
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          CHILD_APPS: ${{ needs.validate-inputs.outputs.CHILD_APPS }}
          SYNC_TIMEOUT: ${{ steps.parse_config.outputs.SYNC_TIMEOUT }}
          IS_DESTRUCTIVE: ${{ needs.validate-inputs.outputs.IS_DESTRUCTIVE }}
        run: |
          set -e

          echo "🔄 Syncing ArgoCD child applications"
          echo "Strategy: ${{ needs.validate-inputs.outputs.IS_DESTRUCTIVE == 'true' && 'destructive (full app sync with all resources)' || 'non-destructive (only OutOfSync resources)' }}"
          
          # Validate required variables
          if [[ -z "${ARGOCD_SERVER}" ]]; then
            echo "❌ ERROR: ARGOCD_SERVER is not set!"
            exit 1
          fi

          sync_failed=false
          failed_apps=""
          synced_count=0
          skipped_count=0
          total_resources_synced=0

          for app in ${CHILD_APPS}; do
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "Processing app: $app"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            
            # Check overall sync status
            app_status=$(argocd app get "$app" --server "${ARGOCD_SERVER}" -o json)
            sync_status=$(echo "$app_status" | jq -r '.status.sync.status // "Unknown"')
            echo "  📊 Overall sync status: $sync_status"
            
            if [[ "${IS_DESTRUCTIVE}" == "true" ]]; then
              # DESTRUCTIVE: Full app sync (will run all sync waves and hooks)
              echo "  🔥 DESTRUCTIVE MODE: Full app sync (includes sync waves/hooks)"
              
              if argocd app sync "$app" --server "${ARGOCD_SERVER}"; then
                echo "  ✅ Full sync completed: $app"
                synced_count=$((synced_count + 1))
              else
                echo "  ❌ Failed to sync $app"
                sync_failed=true
                failed_apps="$failed_apps $app"
              fi
              
            else
              # NON-DESTRUCTIVE: Only sync OutOfSync resources (skip sync waves/hooks)
              echo "  📦 NON-DESTRUCTIVE MODE: Syncing only OutOfSync resources"
              
              if [[ "$sync_status" == "Synced" ]]; then
                echo "  ℹ️  App is already in sync, skipping"
                skipped_count=$((skipped_count + 1))
                continue
              fi
              
              # Get list of OutOfSync resources
              echo "  🔍 Finding OutOfSync resources..."
              out_of_sync_resources=$(echo "$app_status" | jq -r '
                .status.resources[] | 
                select(.status == "OutOfSync") | 
                "\(.kind):\(.namespace)/\(.name)"
              ')
              
              if [[ -z "$out_of_sync_resources" ]]; then
                echo "  ℹ️  No OutOfSync resources found, skipping"
                skipped_count=$((skipped_count + 1))
                continue
              fi
              
              # Count resources
              resource_count=$(echo "$out_of_sync_resources" | wc -l | tr -d ' ')
              echo "  📋 Found $resource_count OutOfSync resource(s):"
              echo "$out_of_sync_resources" | while read resource; do
                echo "      - $resource"
              done
              
              # Sync each OutOfSync resource individually
              echo "  🔄 Syncing OutOfSync resources..."
              resource_sync_failed=false
              
              while IFS= read -r resource; do
                if [[ -n "$resource" ]]; then
                  echo "      Syncing: $resource"
                  
                  # Extract kind and name from the resource string (format: Kind:namespace/name)
                  kind=$(echo "$resource" | cut -d':' -f1)
                  namespace_name=$(echo "$resource" | cut -d':' -f2)
                  namespace=$(echo "$namespace_name" | cut -d'/' -f1)
                  name=$(echo "$namespace_name" | cut -d'/' -f2)
                  
                  # Sync this specific resource only
                  if argocd app sync "$app" \
                    --server "${ARGOCD_SERVER}" \
                    --resource "${kind}:${namespace}/${name}" \
                    --prune=false 2>&1; then
                    echo "        ✅ Synced: $resource"
                    total_resources_synced=$((total_resources_synced + 1))
                  else
                    echo "        ⚠️  Failed to sync: $resource"
                    resource_sync_failed=true
                  fi
                fi
              done <<< "$out_of_sync_resources"
              
              if [[ "$resource_sync_failed" == "true" ]]; then
                echo "  ❌ Some resources failed to sync for $app"
                sync_failed=true
                failed_apps="$failed_apps $app"
              else
                echo "  ✅ All OutOfSync resources synced for: $app"
                synced_count=$((synced_count + 1))
              fi
            fi
            
            sleep 1
          done

          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "📊 Sync Summary"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "  Strategy: ${{ needs.validate-inputs.outputs.IS_DESTRUCTIVE == 'true' && 'Destructive' || 'Non-Destructive' }}"
          echo "  Apps synced: $synced_count"
          echo "  Apps skipped: $skipped_count (already in sync)"
          
          if [[ "${IS_DESTRUCTIVE}" == "false" ]]; then
            echo "  Resources synced: $total_resources_synced (individual OutOfSync resources)"
          fi
          
          if [ "$sync_failed" = true ]; then
            echo "  Apps failed: $(echo $failed_apps | wc -w)"
            echo ""
            echo "❌ ERROR: Failed to sync the following apps:${failed_apps}"
            echo "Deployment cannot continue with failed syncs."
            exit 1
          fi

          echo ""
          echo "✅ All apps/resources synced successfully (health will be checked in next job)"
          echo "APPS_SYNCED=true" >> $GITHUB_OUTPUT

  # ============================================================================
  # WAIT FOR ARGOCD APPS TO BE HEALTHY
  # ============================================================================
  wait-argocd-healthy:
    needs: [validate-inputs, argocd-sync-apps]
    if: success()
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - name: 'Install ArgoCD CLI'
        run: |
          curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x /usr/local/bin/argocd

      - name: 'Login to ArgoCD'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_USERNAME: ${{ secrets.ARGOCD_USERNAME }}
          ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
        run: |
          set -e
          
          echo "🔐 Logging in to ArgoCD server: ${ARGOCD_SERVER}"
          
          if [[ -z "${ARGOCD_SERVER}" ]] || [[ -z "${ARGOCD_USERNAME}" ]] || [[ -z "${ARGOCD_PASSWORD}" ]]; then
            echo "❌ ERROR: ArgoCD credentials not set!"
            exit 1
          fi
          
          argocd login "${ARGOCD_SERVER}" \
            --username "${ARGOCD_USERNAME}" \
            --password "${ARGOCD_PASSWORD}" \
            --insecure
          
          echo "✅ Successfully logged in to ArgoCD"

      - name: 'Wait for ArgoCD apps to be healthy'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          CHILD_APPS: ${{ needs.validate-inputs.outputs.CHILD_APPS }}
        run: |
          set -e

          echo "⏳ Waiting for ArgoCD applications to reach healthy state"

          max_attempts=30
          attempt=1

          for app in ${CHILD_APPS}; do
            echo "Checking health of app: $app"
            attempt=1
            while [ $attempt -le $max_attempts ]; do
              health=$(argocd app get "$app" --server "${ARGOCD_SERVER}" --refresh --output json | jq -r '.status.health.status // "Unknown"')
              sync=$(argocd app get "$app" --server "${ARGOCD_SERVER}" --refresh --output json | jq -r '.status.operationState.phase // "Unknown"')

              echo "  Attempt $attempt/$max_attempts: Health=$health, Sync=$sync"

              if [[ "$health" == "Healthy" ]] && [[ "$sync" != "Running" ]]; then
                echo "✅ App $app is healthy"
                break
              fi

              if [ $attempt -eq $max_attempts ]; then
                echo "⚠️  App $app did not reach healthy state within timeout"
              fi

              attempt=$((attempt + 1))
              sleep 10
            done
          done

          echo "✅ Health check complete"

  # ============================================================================
  # POST-DEPLOYMENT NOTIFICATION
  # ============================================================================
  post-deployment:
    needs: [validate-inputs, approval, update-ten-apps-config, deploy-l1-contracts, wait-argocd-healthy]
    if: |
      (needs.wait-argocd-healthy.result == 'success' || needs.wait-argocd-healthy.result == 'skipped')
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - uses: actions/checkout@v4

      - name: 'Deployment summary'
        run: |
          echo "✅ Deployment workflow completed"
          echo "Environment: ${{ github.event.inputs.testnet_type }}"
          echo "Strategy: ${{ github.event.inputs.deployment_strategy }}"
          echo "Images built: ${{ github.event.inputs.image_build }}"
          echo "Actor: ${{ github.actor }}"

      - name: 'Send repository dispatch to ten-test'
        if: github.event.inputs.testnet_type == 'dev-testnet' || github.event.inputs.testnet_type == 'uat-testnet'
        run: |
          event_type=""
          if [[ "${{ github.event.inputs.testnet_type }}" == "dev-testnet" ]]; then
            event_type="dev_testnet_deployed"
          elif [[ "${{ github.event.inputs.testnet_type }}" == "uat-testnet" ]]; then
            event_type="uat_testnet_deployed"
          fi

          curl -XPOST \
            -H "Authorization: Bearer ${{ secrets.GH_TOKEN }}" \
            -H "Accept: application/vnd.github" \
            -H "Content-Type: application/json" \
            https://api.github.com/repos/ten-protocol/ten-test/dispatches \
            --data "{\"event_type\": \"$event_type\", \"client_payload\": {\"ref\": \"${{ github.ref_name }}\"}}"

      - name: 'Parse advanced config for L2 trigger'
        id: parse_l2_config
        run: |
          ADVANCED_CONFIG="${{ github.event.inputs.advanced_config }}"
          LOG_LEVEL="3"
          [[ "$ADVANCED_CONFIG" =~ log_level=([^ ,]+) ]] && LOG_LEVEL="${BASH_REMATCH[1]}"
          echo "LOG_LEVEL=$LOG_LEVEL" >> $GITHUB_OUTPUT

      - name: 'Trigger L2 contract deployment workflow'
        if: |
          needs.validate-inputs.outputs.IS_DESTRUCTIVE == 'true' &&
          needs.wait-argocd-healthy.result == 'success' &&
          !contains(github.event.inputs.skip_steps, 'l2-trigger')
        run: |
          echo "🚀 Triggering L2 contract deployment workflow..."
          echo "Branch/Ref: ${{ github.ref_name }}"
          echo "Testnet: ${{ github.event.inputs.testnet_type }}"

          gh workflow run manual-deploy-testnet-l2.yml \
            -f testnet_type=${{ github.event.inputs.testnet_type }} \
            -f log_level=${{ steps.parse_l2_config.outputs.LOG_LEVEL }} \
            --ref ${{ github.ref_name }}

          echo "✅ L2 deployment workflow triggered on branch: ${{ github.ref_name }}"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 'Display skipped steps'
        if: github.event.inputs.skip_steps != ''
        run: |
          echo "⚠️  TESTING MODE: The following steps were SKIPPED:"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "${{ github.event.inputs.skip_steps }}" | tr ',' '\n' | sed 's/^/  ✋ /'
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
