name: '[M] k8s Deploy Consolidated'
run-name: '[M] Deploy ${{ github.event.inputs.testnet_type }} (${{ github.event.inputs.deployment_strategy }})'

on:
  push:
    branches:
      - feat/consolidated-deployment-workflow
    paths:
      - '.github/workflows/manual-deploy-k8s-consolidated.yml'
  workflow_dispatch:
    inputs:
      testnet_type:
        description: 'Target Environment'
        required: true
        type: choice
        options:
          - 'dev-testnet'
          - 'uat-testnet'
          - 'sepolia-testnet'
          - 'mainnet'

      deployment_strategy:
        description: 'Deployment Strategy'
        required: true
        type: choice
        options:
          - 'non-destructive'
          - 'destructive'

      image_build:
        description: 'Build & Push Images'
        required: true
        type: choice
        options:
          - 'yes'
          - 'no'

      image_tag:
        description: 'Image Tag (e.g., v1.5.8.0 or leave empty for auto: git tag or commit hash)'
        required: false
        type: string

      use_azure_hsm:
        description: 'Use Azure HSM for enclave signing (yes/no)'
        required: false
        type: choice
        options:
          - 'no'
          - 'yes'
        default: 'no'

      confirmation:
        description: 'Type "confirm" if deploying sepolia or mainnet'
        required: false
        type: string

      log_level:
        description: 'Log Level (1-Error to 5-Trace)'
        required: false
        type: number
        default: 3

      max_gas_gwei:
        description: 'Max gas price in gwei'
        required: false
        type: string
        default: '1.5'

      sync_timeout:
        description: 'ArgoCD Sync Timeout'
        required: false
        type: choice
        options:
          - '5m'
          - '10m'
          - '15m'
          - '20m'
        default: '10m'

      destructive_options:
        description: 'Destructive deployment options (format: node_selectors=sequencer=node1,validator-01=node2,validator-02=node3,gateway=node4|additional_apps=gateway,tools,postgres-client)'
        required: false
        type: string

env:
  REGISTRY: testnetobscuronet.azurecr.io
  REGISTRY_ORG: obscuronet

jobs:
  # ============================================================================
  # VALIDATION & SETUP
  # ============================================================================
  validate-inputs:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'  # Only run on manual triggers
    outputs:
      TESTNET_SHORT_NAME: ${{ steps.setup.outputs.TESTNET_SHORT_NAME }}
      IS_DESTRUCTIVE: ${{ steps.setup.outputs.IS_DESTRUCTIVE }}
      NEEDS_APPROVAL: ${{ steps.setup.outputs.NEEDS_APPROVAL }}
      CONFIG_PATH: ${{ steps.setup.outputs.CONFIG_PATH }}
      CHILD_APPS: ${{ steps.setup.outputs.CHILD_APPS }}
      ADDITIONAL_APPS_TO_DELETE: ${{ steps.setup.outputs.ADDITIONAL_APPS_TO_DELETE }}

    steps:
      - name: 'Check confirmation for production envs'
        run: |
          if [[ ("${{ github.event.inputs.testnet_type }}" == "sepolia-testnet" || "${{ github.event.inputs.testnet_type }}" == "mainnet") && "${{ github.event.inputs.confirmation }}" != "confirm" ]]; then
            echo "‚ùå Confirmation field must say 'confirm' to deploy to sepolia or mainnet"
            exit 1
          fi

      - name: 'Setup environment variables'
        id: setup
        run: |
          TESTNET_TYPE="${{ github.event.inputs.testnet_type }}"

          # Extract short name
          if [[ "$TESTNET_TYPE" == "mainnet" ]]; then
            SHORT_NAME="mainnet"
          else
            SHORT_NAME=${TESTNET_TYPE%-testnet}
          fi
          echo "TESTNET_SHORT_NAME=$SHORT_NAME" >> $GITHUB_OUTPUT

          # Determine config path
          if [[ "$TESTNET_TYPE" == "mainnet" ]]; then
            CONFIG_PATH="prod-argocd-config"
          else
            CONFIG_PATH="nonprod-argocd-config"
          fi
          echo "CONFIG_PATH=$CONFIG_PATH" >> $GITHUB_OUTPUT

          # Check if destructive
          if [[ "${{ github.event.inputs.deployment_strategy }}" == "destructive" ]]; then
            echo "IS_DESTRUCTIVE=true" >> $GITHUB_OUTPUT
          else
            echo "IS_DESTRUCTIVE=false" >> $GITHUB_OUTPUT
          fi

          # Check if approval needed (destructive + sepolia/mainnet)
          if [[ "${{ github.event.inputs.deployment_strategy }}" == "destructive" && ("$TESTNET_TYPE" == "sepolia-testnet" || "$TESTNET_TYPE" == "mainnet") ]]; then
            echo "NEEDS_APPROVAL=true" >> $GITHUB_OUTPUT
          else
            echo "NEEDS_APPROVAL=false" >> $GITHUB_OUTPUT
          fi

          # Set child apps per environment (for syncing)
          case "$TESTNET_TYPE" in
            dev-testnet)
              echo "CHILD_APPS=dev-sequencer dev-validator-01 dev-validator-02 dev-gateway dev-ten-tools" >> $GITHUB_OUTPUT
              ;;
            uat-testnet)
              echo "CHILD_APPS=uat-sequencer uat-validator-01 uat-validator-02 uat-gateway uat-ten-tools" >> $GITHUB_OUTPUT
              ;;
            sepolia-testnet)
              echo "CHILD_APPS=sepolia-sequencer sepolia-validator-01 sepolia-validator-02 sepolia-gateway sepolia-gateway-dexynth sepolia-gateway-pentest sepolia-ten-tools" >> $GITHUB_OUTPUT
              ;;
            mainnet)
              echo "CHILD_APPS=mainnet-sequencer mainnet-validator-01 mainnet-validator-02 mainnet-gateway mainnet-postgres-client mainnet-ten-tools" >> $GITHUB_OUTPUT
              ;;
          esac

          # Parse destructive_options (if provided, destructive only)
          # Format: node_selectors=sequencer=node1,validator-01=node2,validator-02=node3,gateway=node4|additional_apps=gateway,tools,postgres-client
          DESTRUCTIVE_OPTS="${{ github.event.inputs.destructive_options }}"

          # Extract additional_apps from destructive_options
          if [[ "$DESTRUCTIVE_OPTS" =~ additional_apps=([^|]*) ]]; then
            ADDITIONAL_APPS="${BASH_REMATCH[1]}"
            if [[ -n "$ADDITIONAL_APPS" ]]; then
              # Convert comma-separated to environment-prefixed list
              IFS=',' read -ra APPS <<< "$ADDITIONAL_APPS"
              PREFIXED_APPS=""
              for app in "${APPS[@]}"; do
                app=$(echo "$app" | xargs)  # trim whitespace
                prefixed_app="${SHORT_NAME}-${app}"
                PREFIXED_APPS="$PREFIXED_APPS $prefixed_app"
              done
              echo "ADDITIONAL_APPS_TO_DELETE=$PREFIXED_APPS" >> $GITHUB_OUTPUT
            else
              echo "ADDITIONAL_APPS_TO_DELETE=" >> $GITHUB_OUTPUT
            fi
          else
            echo "ADDITIONAL_APPS_TO_DELETE=" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # APPROVAL GATE (only for destructive sepolia/mainnet)
  # ============================================================================
  approval:
    needs: validate-inputs
    runs-on: ubuntu-latest
    if: needs.validate-inputs.outputs.NEEDS_APPROVAL == 'true'
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - name: 'Approval granted for destructive deployment'
        run: |
          echo "‚úÖ Destructive deployment approved by ${{ github.actor }}"
          echo "Environment: ${{ github.event.inputs.testnet_type }}"
          echo "Strategy: destructive"

  # ============================================================================
  # BUILD & PUSH IMAGES (Optional)
  # ============================================================================
  build-images:
    needs: [validate-inputs, approval]
    if: |
      (needs.validate-inputs.outputs.NEEDS_APPROVAL == 'false' || success()) &&
      github.event.inputs.image_build == 'yes'
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    outputs:
      IMAGE_TAG: ${{ steps.get_tag.outputs.IMAGE_TAG }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: 1.25.1

      - name: 'Login via Azure CLI (for HSM)'
        if: github.event.inputs.use_azure_hsm == 'yes'
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: 'Login to Azure docker registry'
        uses: azure/docker-login@v1
        with:
          login-server: testnetobscuronet.azurecr.io
          username: testnetobscuronet
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: 'Determine image tag'
        id: get_tag
        run: |
          # Use provided tag, or git tag, or commit hash
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          else
            # Try git tag first, fall back to short commit hash
            IMAGE_TAG=$(git describe --tags --exact-match 2>/dev/null || git rev-parse --short HEAD)
          fi
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "üì¶ Image tag: $IMAGE_TAG"

      - name: 'Build and push obscuro node images'
        env:
          IMAGE_TAG: ${{ steps.get_tag.outputs.IMAGE_TAG }}
          USE_HSM: ${{ github.event.inputs.use_azure_hsm }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: |
          set -e
          
          # Enable Docker BuildKit for better caching and parallel builds
          export DOCKER_BUILDKIT=1
          export BUILDKIT_PROGRESS=plain
          
          echo "üèóÔ∏è  Building images with tag: ${IMAGE_TAG}"
          echo "Using Docker BuildKit with layer caching"
          
          # Function to build and push in background
          build_and_push() {
            local name=$1
            local dockerfile=$2
            local extra_args=$3
            
            echo "Building ${name}..."
            docker build \
              --cache-from ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/${name}:latest \
              --cache-from ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/${name}:${IMAGE_TAG} \
              -t ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/${name}:${IMAGE_TAG} \
              -f ${dockerfile} \
              ${extra_args} \
              . 2>&1 | sed "s/^/[${name}] /" &
          }
          
          # Build enclave (with optional HSM)
          if [[ "$USE_HSM" == "yes" ]]; then
            echo "üîê Building enclave with Azure HSM..."
            build_and_push "enclave" "dockerfiles/enclave.Dockerfile" \
              "--build-arg AZURE_TENANT_ID=${AZURE_TENANT_ID} --build-arg AZURE_SUBSCRIPTION_ID=${AZURE_SUBSCRIPTION_ID}"
          else
            echo "üì¶ Building enclave without HSM..."
            build_and_push "enclave" "dockerfiles/enclave.Dockerfile" ""
          fi
          
          # Build host and hardhat deployer in parallel
          build_and_push "host" "dockerfiles/host.Dockerfile" ""
          build_and_push "hardhatdeployer" "tools/hardhatdeployer/Dockerfile" ""
          
          # Wait for all builds to complete
          echo "‚è≥ Waiting for all builds to complete..."
          wait
          
          # Check if any build failed
          if [ $? -ne 0 ]; then
            echo "‚ùå One or more builds failed"
            exit 1
          fi
          
          echo "‚úÖ All builds completed successfully"
          echo ""
          echo "üì§ Pushing images..."
          
          # Push all images in parallel
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/enclave:${IMAGE_TAG} &
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/host:${IMAGE_TAG} &
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/hardhatdeployer:${IMAGE_TAG} &
          
          # Wait for all pushes
          wait
          
          echo "‚úÖ All images built and pushed with tag: ${IMAGE_TAG}"

  # ============================================================================
  # UPDATE TEN-APPS YAML WITH NEW IMAGE TAGS
  # ============================================================================
  update-ten-apps-config:
    needs: [validate-inputs, build-images]
    if: github.event.inputs.image_build == 'yes'
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - uses: actions/checkout@v4
        with:
          repository: ten-protocol/ten-apps
          token: ${{ secrets.DEPLOY_ACTIONS_PAT }}
          path: ten-apps

      - name: 'Install yq'
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.1/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: 'Update image tags and node selectors in ten-apps config'
        env:
          IMAGE_TAG: ${{ needs.build-images.outputs.IMAGE_TAG }}
          CONFIG_PATH: ${{ needs.validate-inputs.outputs.CONFIG_PATH }}
          DESTRUCTIVE_OPTIONS_INPUT: ${{ github.event.inputs.destructive_options }}
          IS_DESTRUCTIVE: ${{ needs.validate-inputs.outputs.IS_DESTRUCTIVE }}
        run: |
          cd ten-apps

          # Determine the config directory
          if [[ "${{ github.event.inputs.testnet_type }}" == "mainnet" ]]; then
            ENV_DIR="${{ env.CONFIG_PATH }}/apps/envs/mainnet/valuesFile"
          else
            ENV_DIR="${{ env.CONFIG_PATH }}/apps/envs/${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}/valuesFile"
          fi

          echo "üìù Updating image tags to: ${IMAGE_TAG} in $ENV_DIR"

          # Update all values files with new image tags
          for values_file in "$ENV_DIR"/values-*.yaml; do
            if [ -f "$values_file" ]; then
              filename=$(basename "$values_file")
              echo "  Updating $filename..."

              # Update image tags for core images
              yq eval -i ".enclave.image.tag = \"${IMAGE_TAG}\"" "$values_file" 2>/dev/null || true
              yq eval -i ".enclave02.image.tag = \"${IMAGE_TAG}\"" "$values_file" 2>/dev/null || true
              yq eval -i ".host.image.tag = \"${IMAGE_TAG}\"" "$values_file" 2>/dev/null || true

              # For gateway values files
              yq eval -i ".gateway.image.tag = \"${IMAGE_TAG}\"" "$values_file" 2>/dev/null || true
            fi
          done

          echo "‚úÖ Image tags updated"

          # ‚ö†Ô∏è  NODE SELECTORS ONLY FOR DESTRUCTIVE DEPLOYMENTS
          # Extract node_selectors from destructive_options
          NODE_SELECTORS_INPUT=""
          if [[ "${{ env.DESTRUCTIVE_OPTIONS_INPUT }}" =~ node_selectors=([^|]*) ]]; then
            NODE_SELECTORS_INPUT="${BASH_REMATCH[1]}"
          fi

          if [[ "${{ env.IS_DESTRUCTIVE }}" == "true" ]] && [[ -n "$NODE_SELECTORS_INPUT" ]]; then
            echo "üî• DESTRUCTIVE deployment: Parsing and applying node selectors"

            # Parse node_selectors input (format: sequencer=node1,validator-01=node2,validator-02=node3,gateway=node4)
            declare -A node_selectors
            IFS=',' read -ra pairs <<< "$NODE_SELECTORS_INPUT"
            for pair in "${pairs[@]}"; do
              key="${pair%%=*}"
              value="${pair##*=}"
              node_selectors["$key"]="$value"
            done

            # Update sequencer node selector (if provided)
            if [[ -n "${node_selectors[sequencer]}" ]]; then
              echo "üìç Updating sequencer node selector to: ${node_selectors[sequencer]}"
              seq_file="$ENV_DIR/values-${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}-sequencer.yaml"
              if [ -f "$seq_file" ]; then
                yq eval -i ".enclave.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[sequencer]}\"" "$seq_file"
                yq eval -i ".enclave02.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[sequencer]}\"" "$seq_file" 2>/dev/null || true
                yq eval -i ".host.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[sequencer]}\"" "$seq_file"
                echo "‚úÖ Sequencer node selector updated"
              fi
            fi

            # Update validator-01 node selector (if provided)
            if [[ -n "${node_selectors[validator-01]}" ]]; then
              echo "üìç Updating validator-01 node selector to: ${node_selectors[validator-01]}"
              val1_file="$ENV_DIR/values-${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}-validator-01.yaml"
              if [ -f "$val1_file" ]; then
                yq eval -i ".enclave.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[validator-01]}\"" "$val1_file"
                yq eval -i ".enclave02.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[validator-01]}\"" "$val1_file" 2>/dev/null || true
                yq eval -i ".host.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[validator-01]}\"" "$val1_file"
                echo "‚úÖ Validator-01 node selector updated"
              fi
            fi

            # Update validator-02 node selector (if provided)
            if [[ -n "${node_selectors[validator-02]}" ]]; then
              echo "üìç Updating validator-02 node selector to: ${node_selectors[validator-02]}"
              val2_file="$ENV_DIR/values-${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}-validator-02.yaml"
              if [ -f "$val2_file" ]; then
                yq eval -i ".enclave.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[validator-02]}\"" "$val2_file"
                yq eval -i ".enclave02.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[validator-02]}\"" "$val2_file" 2>/dev/null || true
                yq eval -i ".host.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[validator-02]}\"" "$val2_file"
                echo "‚úÖ Validator-02 node selector updated"
              fi
            fi

            # Update gateway node selector (if provided)
            if [[ -n "${node_selectors[gateway]}" ]]; then
              echo "üìç Updating gateway node selector to: ${node_selectors[gateway]}"
              gw_file="$ENV_DIR/values-${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}-gateway.yaml"
              if [ -f "$gw_file" ]; then
                yq eval -i ".gateway.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[gateway]}\"" "$gw_file"
                echo "‚úÖ Gateway node selector updated"
              fi
            fi
          elif [[ "${{ env.IS_DESTRUCTIVE }}" != "true" ]]; then
            echo "üìå NON-DESTRUCTIVE deployment: Skipping node selector updates"
          else
            echo "‚ÑπÔ∏è  No node selectors provided"
          fi

          # Commit changes
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add "$ENV_DIR/values-*.yaml"

          if git diff --cached --quiet; then
            echo "‚ÑπÔ∏è  No changes to commit"
          else
            commit_msg="chore: update "
            [[ "${{ env.IMAGE_TAG }}" != "" ]] && commit_msg+="image tags to ${{ env.IMAGE_TAG }}"

            if [[ "${{ env.IS_DESTRUCTIVE }}" == "true" ]] && [[ -n "$NODE_SELECTORS_INPUT" ]]; then
              [[ "${{ env.IMAGE_TAG }}" != "" ]] && commit_msg+=" and "
              commit_msg+="node selectors"
            fi

            commit_msg+=" for ${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}"

            git commit -m "$commit_msg"
            git push
            echo "‚úÖ Updated and pushed changes to ten-apps"
          fi

  # ============================================================================
  # DEPLOY L1 CONTRACTS (Destructive only)
  # ============================================================================
  deploy-l1-contracts:
    needs: [validate-inputs, approval, update-ten-apps-config]
    if: |
      (needs.validate-inputs.outputs.NEEDS_APPROVAL == 'false' || success()) &&
      needs.validate-inputs.outputs.IS_DESTRUCTIVE == 'true'
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    outputs:
      NETWORK_CONFIG_ADDR: ${{ steps.deploy.outputs.NETWORK_CONFIG_ADDR }}
      MSG_BUS_CONTRACT_ADDR: ${{ steps.deploy.outputs.MSG_BUS_CONTRACT_ADDR }}
      BRIDGE_CONTRACT_ADDR: ${{ steps.deploy.outputs.BRIDGE_CONTRACT_ADDR }}
      CROSS_CHAIN_ADDR: ${{ steps.deploy.outputs.CROSS_CHAIN_ADDR }}
      DA_REGISTRY_ADDR: ${{ steps.deploy.outputs.DA_REGISTRY_ADDR }}
      ENCLAVE_REGISTRY_ADDR: ${{ steps.deploy.outputs.ENCLAVE_REGISTRY_ADDR }}
      L1_START_HASH: ${{ steps.deploy.outputs.L1_START_HASH }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: 1.25.1

      - name: 'Login via Azure CLI'
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: 'Login to Azure docker registry'
        uses: azure/docker-login@v1
        with:
          login-server: ${{ env.REGISTRY }}
          username: testnetobscuronet
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: 'Deploy Contracts'
        id: deployContracts
        shell: bash
        env:
          DOCKER_API_VERSION: "1.45"
          DEPLOY_DOCKERIMAGE: ${{ vars.DOCKER_BUILD_TAG_L2_HARDHAT_DEPLOYER }}
          DEPLOY_NETWORKNAME: ${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}
          DEPLOY_GITHUBPAT: ${{ secrets.DEPLOY_ACTIONS_PAT }}
          DEPLOY_OUTPUTENV: ./testnet/.env
          DEPLOY_L1_RPCADDRESS: ${{ secrets.L1_HTTP_URL }}
          DEPLOY_L1_DEPLOYERPK: ${{ secrets.ACCOUNT_PK_WORKER }}
          DEPLOY_L1_INITIALSEQADDRESS: ${{ vars.ACCOUNT_ADDR_NODE_0 }}
          DEPLOY_L1_ETHERSCANAPIKEY: ${{ secrets.ETHERSCAN_API_KEY }}
          DEPLOY_L1_MAXGASGWEI: ${{ github.event.inputs.max_gas_gwei }}
          DEPLOY_L1_CHECKGASPRICE: ${{ github.event.inputs.testnet_type == 'mainnet' && 'true' || 'false' }}
        run: |
          # Run deployer and capture output
          go run ./testnet/launcher/l1contractdeployer/cmd
          
          if [ -f ./testnet/.env ]; then
            source ./testnet/.env
          fi          
          # Fix variable names and GITHUB_OUTPUT reference
          echo "NETWORK_CONFIG_ADDR=$NETWORKCONFIGADDR" >> $GITHUB_ENV
          echo "NETWORK_CONFIG_ADDR=$NETWORKCONFIGADDR" >> $GITHUB_OUTPUT
          
          echo "MSG_BUS_CONTRACT_ADDR=$MSGBUSCONTRACTADDR" >> $GITHUB_ENV
          echo "MSG_BUS_CONTRACT_ADDR=$MSGBUSCONTRACTADDR" >> $GITHUB_OUTPUT
          
          echo "BRIDGE_CONTRACT_ADDR=$BRIDGECONTRACTADDR" >> $GITHUB_ENV
          echo "BRIDGE_CONTRACT_ADDR=$BRIDGECONTRACTADDR" >> $GITHUB_OUTPUT
          
          echo "CROSS_CHAIN_ADDR=$CROSSCHAINADDR" >> $GITHUB_ENV
          echo "CROSS_CHAIN_ADDR=$CROSSCHAINADDR" >> $GITHUB_OUTPUT
          
          echo "DA_REGISTRY_ADDR=$DAREGISTRYADDR" >> $GITHUB_ENV
          echo "DA_REGISTRY_ADDR=$DAREGISTRYADDR" >> $GITHUB_OUTPUT
          
          echo "ENCLAVE_REGISTRY_ADDR=$ENCLAVEREGISTRYADDR" >> $GITHUB_ENV
          echo "ENCLAVE_REGISTRY_ADDR=$ENCLAVEREGISTRYADDR" >> $GITHUB_OUTPUT
          
          echo "L1_START_HASH=$L1START" >> $GITHUB_ENV
          echo "L1_START_HASH=$L1START" >> $GITHUB_OUTPUT

      - name: 'Save L1 deployer container logs'
        # Wait to make sure the logs are available in the container
        if: ${{ always() }} # Always run this step to ensure logs are captured even if previous steps fail
        run: |
          sleep 60
          docker logs `docker ps -aqf "name=hh-l1-deployer"` > deploy-l1-contracts.out 2>&1
          
      - name: 'Upload L1 deployer container logs'
        if: ${{ always() }} # Always run this step to ensure logs are uploaded even if previous steps fail
        uses: actions/upload-artifact@v4
        with:
          name: deploy-l1-artifacts
          path: |
            deploy-l1-contracts.out
          retention-days: 2

  # ============================================================================
  # ARGOCD - DELETE CHILD APPS (Destructive only)
  # ============================================================================
  argocd-delete-child-apps:
    needs: [validate-inputs, approval, deploy-l1-contracts]
    if: |
      (needs.validate-inputs.outputs.NEEDS_APPROVAL == 'false' || success()) &&
      needs.validate-inputs.outputs.IS_DESTRUCTIVE == 'true'
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - name: 'Install ArgoCD CLI'
        run: |
          curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x /usr/local/bin/argocd

      - name: 'Login to ArgoCD'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_USERNAME: ${{ secrets.ARGOCD_USERNAME }}
          ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
        run: |
          set -e
          
          echo "üîê Logging in to ArgoCD server: ${ARGOCD_SERVER}"
          
          if [[ -z "${ARGOCD_SERVER}" ]] || [[ -z "${ARGOCD_USERNAME}" ]] || [[ -z "${ARGOCD_PASSWORD}" ]]; then
            echo "‚ùå ERROR: ArgoCD credentials not set!"
            exit 1
          fi
          
          argocd login "${ARGOCD_SERVER}" \
            --username "${ARGOCD_USERNAME}" \
            --password "${ARGOCD_PASSWORD}" \
            --insecure
          
          echo "‚úÖ Successfully logged in to ArgoCD"

      - name: 'Delete ArgoCD child applications and sync parent'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          DEFAULT_APPS: "sequencer validator-01 validator-02"
          ADDITIONAL_APPS: ${{ needs.validate-inputs.outputs.ADDITIONAL_APPS_TO_DELETE }}
          TESTNET_SHORT_NAME: ${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}
        run: |
          set -e

          echo "üî• DESTRUCTIVE DEPLOYMENT: Delete child apps and sync parent"
          echo "Environment: ${{ github.event.inputs.testnet_type }}"
          echo ""
          
          # Validate required variables
          if [[ -z "${ARGOCD_SERVER}" ]]; then
            echo "‚ùå ERROR: ARGOCD_SERVER is not set!"
            exit 1
          fi
          
          # Determine parent app name based on environment
          PARENT_APP="${TESTNET_SHORT_NAME}-testnet"
          echo "üìå Parent app: $PARENT_APP"
          echo ""

          # Step 1: Delete child apps
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "STEP 1: Delete child applications"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          
          # Always delete default apps (sequencer, validator-01, validator-02)
          echo "Default apps to delete: sequencer, validator-01, validator-02"
          for app_suffix in ${DEFAULT_APPS}; do
            app="${TESTNET_SHORT_NAME}-${app_suffix}"
            echo "  üóëÔ∏è  Deleting: $app"
            if ! argocd app delete "$app" --server "${ARGOCD_SERVER}" --cascade --yes 2>&1 | tee /tmp/argocd_output.txt; then
              if grep -q "NotFound\|not found" /tmp/argocd_output.txt; then
                echo "     ‚ÑπÔ∏è  App not found (this is OK)"
              else
                echo "     ‚ùå Failed to delete app"
                exit 1
              fi
            else
              echo "     ‚úÖ Deleted"
            fi
            sleep 2
          done

          # Delete additional apps if specified
          if [[ -n "${ADDITIONAL_APPS}" ]]; then
            echo ""
            echo "Additional apps to delete: ${ADDITIONAL_APPS}"
            for app in ${ADDITIONAL_APPS}; do
              echo "  üóëÔ∏è  Deleting: $app"
              if ! argocd app delete "$app" --server "${ARGOCD_SERVER}" --cascade --yes 2>&1 | tee /tmp/argocd_output.txt; then
                if grep -q "NotFound\|not found" /tmp/argocd_output.txt; then
                  echo "     ‚ÑπÔ∏è  App not found (this is OK)"
                else
                  echo "     ‚ùå Failed to delete app"
                  exit 1
                fi
              else
                echo "     ‚úÖ Deleted"
              fi
              sleep 2
            done
          fi
          
          echo ""
          echo "‚úÖ Child apps deleted"
          echo ""
          
          # Step 2: Sync parent app to recreate child apps
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "STEP 2: Sync parent app to recreate children"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üîÑ Syncing parent app: $PARENT_APP"
          
          if argocd app sync "$PARENT_APP" --server "${ARGOCD_SERVER}"; then
            echo "‚úÖ Parent app synced - child apps should be recreated"
          else
            echo "‚ùå Failed to sync parent app"
            exit 1
          fi
          
          echo ""
          echo "‚è≥ Waiting 10 seconds for child apps to be created..."
          sleep 10
          
          echo ""
          echo "‚úÖ Destructive delete and recreate complete"
          echo "   Child apps will be fully synced in the next job"

  # ============================================================================
  # ARGOCD - DELETE DEPLOYMENTS/STS (Non-Destructive only)
  # ============================================================================
  argocd-delete-resources:
    needs: [validate-inputs, approval]
    if: |
      always() &&
      (needs.validate-inputs.outputs.NEEDS_APPROVAL == 'false' || success()) &&
      needs.validate-inputs.outputs.IS_DESTRUCTIVE == 'false'
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - name: 'Install ArgoCD CLI'
        run: |
          curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x /usr/local/bin/argocd

      - name: 'Login to ArgoCD'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_USERNAME: ${{ secrets.ARGOCD_USERNAME }}
          ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
        run: |
          set -e
          
          echo "üîê Logging in to ArgoCD server: ${ARGOCD_SERVER}"
          
          # Validate credentials are set
          if [[ -z "${ARGOCD_SERVER}" ]]; then
            echo "‚ùå ERROR: ARGOCD_SERVER is not set!"
            exit 1
          fi
          
          if [[ -z "${ARGOCD_USERNAME}" ]] || [[ -z "${ARGOCD_PASSWORD}" ]]; then
            echo "‚ùå ERROR: ARGOCD_USERNAME or ARGOCD_PASSWORD is not set!"
            exit 1
          fi
          
          # Login to ArgoCD
          argocd login "${ARGOCD_SERVER}" \
            --username "${ARGOCD_USERNAME}" \
            --password "${ARGOCD_PASSWORD}" \
            --insecure
          
          echo "‚úÖ Successfully logged in to ArgoCD"

      - name: 'Delete host and enclave deployments/statefulsets via ArgoCD'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          TESTNET_SHORT_NAME: ${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}
        run: |
          set -e

          echo "üóëÔ∏è  Non-destructive deployment: Deleting host and enclave deployments/statefulsets"
          echo "Environment: ${TESTNET_SHORT_NAME}"
          echo "ArgoCD Server: ${ARGOCD_SERVER}"
          
          # Validate required variables
          if [[ -z "${ARGOCD_SERVER}" ]]; then
            echo "‚ùå ERROR: ARGOCD_SERVER is not set!"
            exit 1
          fi
          
          if [[ -z "${TESTNET_SHORT_NAME}" ]]; then
            echo "‚ùå ERROR: TESTNET_SHORT_NAME is not set!"
            exit 1
          fi

          APPS=("sequencer" "validator-01" "validator-02")

          for app_suffix in "${APPS[@]}"; do
            app="${TESTNET_SHORT_NAME}-${app_suffix}"
            echo "Processing app: $app"

            # Delete host deployment (only ignore NotFound errors)
            echo "  Deleting host deployment..."
            if ! argocd app delete-resource "$app" \
              --server "${ARGOCD_SERVER}" \
              --kind Deployment \
              --resource-name "${app}-host" \
              --all 2>&1 | tee /tmp/argocd_output.txt; then
              if grep -q "NotFound\|not found" /tmp/argocd_output.txt; then
                echo "  ‚ÑπÔ∏è  Host deployment not found (this is OK)"
              else
                echo "  ‚ùå Failed to delete host deployment"
                exit 1
              fi
            fi

            # Delete enclave statefulset (only ignore NotFound errors)
            echo "  Deleting enclave statefulset..."
            if ! argocd app delete-resource "$app" \
              --server "${ARGOCD_SERVER}" \
              --kind StatefulSet \
              --resource-name "${app}-enclave" \
              --all 2>&1 | tee /tmp/argocd_output.txt; then
              if grep -q "NotFound\|not found" /tmp/argocd_output.txt; then
                echo "  ‚ÑπÔ∏è  Enclave statefulset not found (this is OK)"
              else
                echo "  ‚ùå Failed to delete enclave statefulset"
                exit 1
              fi
            fi

            # Delete enclave02 statefulset (only ignore NotFound errors)
            echo "  Deleting enclave02 statefulset..."
            if ! argocd app delete-resource "$app" \
              --server "${ARGOCD_SERVER}" \
              --kind StatefulSet \
              --resource-name "${app}-enclave02" \
              --all 2>&1 | tee /tmp/argocd_output.txt; then
              if grep -q "NotFound\|not found" /tmp/argocd_output.txt; then
                echo "  ‚ÑπÔ∏è  Enclave02 statefulset not found (this is OK)"
              else
                echo "  ‚ùå Failed to delete enclave02 statefulset"
                exit 1
              fi
            fi

            sleep 2
          done

          echo "‚úÖ Resource deletion complete"

  # ============================================================================
  # ARGOCD - SYNC APPLICATIONS
  # ============================================================================
  argocd-sync-apps:
    needs: [validate-inputs, approval, deploy-l1-contracts, argocd-delete-child-apps, argocd-delete-resources]
    if: |
      always() &&
      (needs.validate-inputs.outputs.NEEDS_APPROVAL == 'false' || success()) &&
      (needs.argocd-delete-child-apps.result == 'success' || needs.argocd-delete-child-apps.result == 'skipped') &&
      (needs.argocd-delete-resources.result == 'success' || needs.argocd-delete-resources.result == 'skipped')
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    outputs:
      APPS_SYNCED: ${{ steps.sync.outputs.APPS_SYNCED }}

    steps:
      - name: 'Install ArgoCD CLI'
        run: |
          curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x /usr/local/bin/argocd

      - name: 'Login to ArgoCD'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_USERNAME: ${{ secrets.ARGOCD_USERNAME }}
          ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
        run: |
          set -e
          
          echo "üîê Logging in to ArgoCD server: ${ARGOCD_SERVER}"
          
          if [[ -z "${ARGOCD_SERVER}" ]] || [[ -z "${ARGOCD_USERNAME}" ]] || [[ -z "${ARGOCD_PASSWORD}" ]]; then
            echo "‚ùå ERROR: ArgoCD credentials not set!"
            exit 1
          fi
          
          argocd login "${ARGOCD_SERVER}" \
            --username "${ARGOCD_USERNAME}" \
            --password "${ARGOCD_PASSWORD}" \
            --insecure
          
          echo "‚úÖ Successfully logged in to ArgoCD"

      - name: 'Sync ArgoCD child applications'
        id: sync
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          CHILD_APPS: ${{ needs.validate-inputs.outputs.CHILD_APPS }}
          SYNC_TIMEOUT: ${{ github.event.inputs.sync_timeout }}
          IS_DESTRUCTIVE: ${{ needs.validate-inputs.outputs.IS_DESTRUCTIVE }}
        run: |
          set -e

          echo "üîÑ Syncing ArgoCD child applications"
          echo "Strategy: ${{ needs.validate-inputs.outputs.IS_DESTRUCTIVE == 'true' && 'destructive (full app sync with all resources)' || 'non-destructive (only OutOfSync resources)' }}"
          
          # Validate required variables
          if [[ -z "${ARGOCD_SERVER}" ]]; then
            echo "‚ùå ERROR: ARGOCD_SERVER is not set!"
            exit 1
          fi

          sync_failed=false
          failed_apps=""
          synced_count=0
          skipped_count=0
          total_resources_synced=0

          for app in ${CHILD_APPS}; do
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "Processing app: $app"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            
            # Check overall sync status
            app_status=$(argocd app get "$app" --server "${ARGOCD_SERVER}" -o json)
            sync_status=$(echo "$app_status" | jq -r '.status.sync.status // "Unknown"')
            echo "  üìä Overall sync status: $sync_status"
            
            if [[ "${IS_DESTRUCTIVE}" == "true" ]]; then
              # DESTRUCTIVE: Full app sync (will run all sync waves and hooks)
              echo "  üî• DESTRUCTIVE MODE: Full app sync (includes sync waves/hooks)"
              
              if argocd app sync "$app" --server "${ARGOCD_SERVER}"; then
                echo "  ‚úÖ Full sync completed: $app"
                synced_count=$((synced_count + 1))
              else
                echo "  ‚ùå Failed to sync $app"
                sync_failed=true
                failed_apps="$failed_apps $app"
              fi
              
            else
              # NON-DESTRUCTIVE: Only sync OutOfSync resources (skip sync waves/hooks)
              echo "  üì¶ NON-DESTRUCTIVE MODE: Syncing only OutOfSync resources"
              
              if [[ "$sync_status" == "Synced" ]]; then
                echo "  ‚ÑπÔ∏è  App is already in sync, skipping"
                skipped_count=$((skipped_count + 1))
                continue
              fi
              
              # Get list of OutOfSync resources
              echo "  üîç Finding OutOfSync resources..."
              out_of_sync_resources=$(echo "$app_status" | jq -r '
                .status.resources[] | 
                select(.status == "OutOfSync") | 
                "\(.kind):\(.namespace)/\(.name)"
              ')
              
              if [[ -z "$out_of_sync_resources" ]]; then
                echo "  ‚ÑπÔ∏è  No OutOfSync resources found, skipping"
                skipped_count=$((skipped_count + 1))
                continue
              fi
              
              # Count resources
              resource_count=$(echo "$out_of_sync_resources" | wc -l | tr -d ' ')
              echo "  üìã Found $resource_count OutOfSync resource(s):"
              echo "$out_of_sync_resources" | while read resource; do
                echo "      - $resource"
              done
              
              # Sync each OutOfSync resource individually
              echo "  üîÑ Syncing OutOfSync resources..."
              resource_sync_failed=false
              
              while IFS= read -r resource; do
                if [[ -n "$resource" ]]; then
                  echo "      Syncing: $resource"
                  
                  # Extract kind and name from the resource string (format: Kind:namespace/name)
                  kind=$(echo "$resource" | cut -d':' -f1)
                  namespace_name=$(echo "$resource" | cut -d':' -f2)
                  namespace=$(echo "$namespace_name" | cut -d'/' -f1)
                  name=$(echo "$namespace_name" | cut -d'/' -f2)
                  
                  # Sync this specific resource only
                  if argocd app sync "$app" \
                    --server "${ARGOCD_SERVER}" \
                    --resource "${kind}:${namespace}/${name}" \
                    --prune=false 2>&1; then
                    echo "        ‚úÖ Synced: $resource"
                    total_resources_synced=$((total_resources_synced + 1))
                  else
                    echo "        ‚ö†Ô∏è  Failed to sync: $resource"
                    resource_sync_failed=true
                  fi
                fi
              done <<< "$out_of_sync_resources"
              
              if [[ "$resource_sync_failed" == "true" ]]; then
                echo "  ‚ùå Some resources failed to sync for $app"
                sync_failed=true
                failed_apps="$failed_apps $app"
              else
                echo "  ‚úÖ All OutOfSync resources synced for: $app"
                synced_count=$((synced_count + 1))
              fi
            fi
            
            sleep 1
          done

          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üìä Sync Summary"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "  Strategy: ${{ needs.validate-inputs.outputs.IS_DESTRUCTIVE == 'true' && 'Destructive' || 'Non-Destructive' }}"
          echo "  Apps synced: $synced_count"
          echo "  Apps skipped: $skipped_count (already in sync)"
          
          if [[ "${IS_DESTRUCTIVE}" == "false" ]]; then
            echo "  Resources synced: $total_resources_synced (individual OutOfSync resources)"
          fi
          
          if [ "$sync_failed" = true ]; then
            echo "  Apps failed: $(echo $failed_apps | wc -w)"
            echo ""
            echo "‚ùå ERROR: Failed to sync the following apps:${failed_apps}"
            echo "Deployment cannot continue with failed syncs."
            exit 1
          fi

          echo ""
          echo "‚úÖ All apps/resources synced successfully (health will be checked in next job)"
          echo "APPS_SYNCED=true" >> $GITHUB_OUTPUT

  # ============================================================================
  # WAIT FOR ARGOCD APPS TO BE HEALTHY
  # ============================================================================
  wait-argocd-healthy:
    needs: [validate-inputs, argocd-sync-apps]
    if: success()
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - name: 'Install ArgoCD CLI'
        run: |
          curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x /usr/local/bin/argocd

      - name: 'Login to ArgoCD'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_USERNAME: ${{ secrets.ARGOCD_USERNAME }}
          ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
        run: |
          set -e
          
          echo "üîê Logging in to ArgoCD server: ${ARGOCD_SERVER}"
          
          if [[ -z "${ARGOCD_SERVER}" ]] || [[ -z "${ARGOCD_USERNAME}" ]] || [[ -z "${ARGOCD_PASSWORD}" ]]; then
            echo "‚ùå ERROR: ArgoCD credentials not set!"
            exit 1
          fi
          
          argocd login "${ARGOCD_SERVER}" \
            --username "${ARGOCD_USERNAME}" \
            --password "${ARGOCD_PASSWORD}" \
            --insecure
          
          echo "‚úÖ Successfully logged in to ArgoCD"

      - name: 'Wait for ArgoCD apps to be healthy'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          CHILD_APPS: ${{ needs.validate-inputs.outputs.CHILD_APPS }}
        run: |
          set -e

          echo "‚è≥ Waiting for ArgoCD applications to reach healthy state"

          max_attempts=30
          attempt=1

          for app in ${CHILD_APPS}; do
            echo "Checking health of app: $app"
            attempt=1
            while [ $attempt -le $max_attempts ]; do
              health=$(argocd app get "$app" --server "${ARGOCD_SERVER}" --refresh --output json | jq -r '.status.health.status // "Unknown"')
              sync=$(argocd app get "$app" --server "${ARGOCD_SERVER}" --refresh --output json | jq -r '.status.operationState.phase // "Unknown"')

              echo "  Attempt $attempt/$max_attempts: Health=$health, Sync=$sync"

              if [[ "$health" == "Healthy" ]] && [[ "$sync" != "Running" ]]; then
                echo "‚úÖ App $app is healthy"
                break
              fi

              if [ $attempt -eq $max_attempts ]; then
                echo "‚ö†Ô∏è  App $app did not reach healthy state within timeout"
              fi

              attempt=$((attempt + 1))
              sleep 10
            done
          done

          echo "‚úÖ Health check complete"

  # ============================================================================
  # DEPLOY L2 CONTRACTS (Destructive only)
  # ============================================================================
  deploy-l2-contracts:
    needs: [validate-inputs, deploy-l1-contracts, wait-argocd-healthy]
    if: |
      (needs.validate-inputs.outputs.NEEDS_APPROVAL == 'false' || success()) &&
      needs.validate-inputs.outputs.IS_DESTRUCTIVE == 'true'
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/checkout@v4
        with:
          repository: ten-protocol/ten-apps
          token: ${{ secrets.DEPLOY_ACTIONS_PAT }}
          path: cfg

      - uses: actions/setup-go@v5
        with:
          go-version: 1.25.1

      - name: 'Login via Azure CLI'
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: 'Login to Azure docker registry'
        uses: azure/docker-login@v1
        with:
          login-server: ${{ env.REGISTRY }}
          username: testnetobscuronet
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: 'Parse L1 config'
        id: parse_l1_config
        env:
          CONFIG_PATH: ${{ needs.validate-inputs.outputs.CONFIG_PATH }}
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.1/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

          # Determine config file
          if [[ "${{ github.event.inputs.testnet_type }}" == "mainnet" ]]; then
            CFG="cfg/${{ env.CONFIG_PATH }}/apps/envs/mainnet/valuesFile/l1-values.yaml"
          else
            CFG="cfg/${{ env.CONFIG_PATH }}/apps/envs/${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}/valuesFile/l1-values.yaml"
          fi

          echo "network_config=$(yq -r '.l1Config.networkConfig' "$CFG")" >> $GITHUB_OUTPUT
          echo "message_bus=$(yq -r '.l1Config.messagebus' "$CFG")" >> $GITHUB_OUTPUT
          echo "rollup=$(yq -r '.l1Config.rollup' "$CFG")" >> $GITHUB_OUTPUT
          echo "crosschain=$(yq -r '.l1Config.crosschain' "$CFG")" >> $GITHUB_OUTPUT
          echo "enclave_registry=$(yq -r '.l1Config.enclaveRegistry' "$CFG")" >> $GITHUB_OUTPUT

      - name: 'Deploy L2 contracts'
        id: deployL2Contracts
        shell: bash
        env:
          DOCKER_API_VERSION: "1.45"
          DEPLOY_DOCKERIMAGE: ${{ vars.DOCKER_BUILD_TAG_L2_HARDHAT_DEPLOYER }}
          DEPLOY_L1_DEPLOYERPK: ${{ secrets.ACCOUNT_PK_WORKER }}
          DEPLOY_L1_RPCADDRESS: ${{ secrets.L1_HTTP_URL }}
          DEPLOY_L2_DEPLOYERPK: ${{ secrets.L2_DEPLOYER_KEY }}
          DEPLOY_L2_RPCADDRESS: ${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}-validator-01.ten.xyz
          DEPLOY_L2_HTTPPORT: 80
          DEPLOY_L2_WSPORT: 81
          DEPLOY_L2_FAUCETPREFUND: ${{ vars.FAUCET_INITIAL_FUNDS }}
          NETWORK_L1_CONTRACTS_NETWORKCONFIG: ${{ steps.parse_l1_config.outputs.network_config }}
          NETWORK_L1_CONTRACTS_MESSAGEBUS: ${{ steps.parse_l1_config.outputs.message_bus }}
          NETWORK_L1_CONTRACTS_ROLLUP: ${{ steps.parse_l1_config.outputs.rollup }}
          NETWORK_L1_CONTRACTS_CROSSCHAIN: ${{ steps.parse_l1_config.outputs.crosschain }}
          NETWORK_L1_CONTRACTS_ENCLAVEREGISTRY: ${{ steps.parse_l1_config.outputs.enclave_registry }}
          NETWORK_CHAINID: ${{ vars.CHAIN_ID }}
        run: |
          go run ./testnet/launcher/l2contractdeployer/cmd \

      - name: 'Save L2 deployer container logs'
        if: ${{ always() }} # Always run this step to ensure logs are captured even if previous steps fail
        run: |
          docker logs `docker ps -aqf "name=hh-l2-deployer"` > deploy-l2-contracts.out 2>&1

      - name: 'Upload L2 deployer container logs'
        if: ${{ always() }} # Always run this step to ensure logs are uploaded even if previous steps fail
        uses: actions/upload-artifact@v4
        with:
          name: deploy-l2-artifacts
          path: |
            deploy-l2-contracts.out
          retention-days: 2

  # ============================================================================
  # POST-DEPLOYMENT NOTIFICATION
  # ============================================================================
  post-deployment:
    needs: [validate-inputs, deploy-l1-contracts, deploy-l2-contracts]
    if: |
      always() &&
      (needs.validate-inputs.outputs.NEEDS_APPROVAL == 'false' || success())
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - uses: actions/checkout@v4

      - name: 'Deployment summary'
        run: |
          echo "‚úÖ Deployment workflow completed"
          echo "Environment: ${{ github.event.inputs.testnet_type }}"
          echo "Strategy: ${{ github.event.inputs.deployment_strategy }}"
          echo "Images built: ${{ github.event.inputs.image_build }}"
          echo "Actor: ${{ github.actor }}"

      - name: 'Send repository dispatch to ten-test'
        if: github.event.inputs.testnet_type == 'dev-testnet' || github.event.inputs.testnet_type == 'uat-testnet'
        run: |
          event_type=""
          if [[ "${{ github.event.inputs.testnet_type }}" == "dev-testnet" ]]; then
            event_type="dev_testnet_deployed"
          elif [[ "${{ github.event.inputs.testnet_type }}" == "uat-testnet" ]]; then
            event_type="uat_testnet_deployed"
          fi

          curl -XPOST \
            -H "Authorization: Bearer ${{ secrets.GH_TOKEN }}" \
            -H "Accept: application/vnd.github" \
            -H "Content-Type: application/json" \
            https://api.github.com/repos/ten-protocol/ten-test/dispatches \
            --data "{\"event_type\": \"$event_type\", \"client_payload\": {\"ref\": \"${{ github.ref_name }}\"}}"
