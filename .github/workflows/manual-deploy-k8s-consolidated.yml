name: '[M] k8s Deploy Consolidated'
run-name: '[M] Deploy ${{ github.event.inputs.testnet_type }} (${{ github.event.inputs.deployment_strategy }})'

on:
  push:
    branches:
      - feat/consolidated-deployment-workflow
    paths:
      - '.github/workflows/manual-deploy-k8s-consolidated.yml'
  workflow_dispatch:
    inputs:
      testnet_type:
        description: 'Target Environment'
        required: true
        type: choice
        options:
          - 'dev-testnet'
          - 'uat-testnet'
          - 'sepolia-testnet'
          - 'mainnet'

      deployment_strategy:
        description: 'Deployment Strategy'
        required: true
        type: choice
        options:
          - 'non-destructive'
          - 'destructive'

      image_build:
        description: 'Build & Push Images'
        required: true
        type: choice
        options:
          - 'yes'
          - 'no'

      image_tag:
        description: 'Image Tag (e.g., v1.5.8.0 or leave empty for auto: git tag or commit hash)'
        required: false
        type: string

      use_azure_hsm:
        description: 'Use Azure HSM for enclave signing (yes/no)'
        required: false
        type: choice
        options:
          - 'no'
          - 'yes'
        default: 'no'

      confirmation:
        description: 'Type "confirm" if deploying sepolia or mainnet'
        required: false
        type: string

      log_level:
        description: 'Log Level (1-Error to 5-Trace)'
        required: false
        type: number
        default: 3

      max_gas_gwei:
        description: 'Max gas price in gwei'
        required: false
        type: string
        default: '1.5'

      sync_timeout:
        description: 'ArgoCD Sync Timeout'
        required: false
        type: choice
        options:
          - '5m'
          - '10m'
          - '15m'
          - '20m'
        default: '10m'

      destructive_options:
        description: 'Destructive deployment options (format: node_selectors=sequencer=node1,validator-01=node2,validator-02=node3,gateway=node4|additional_apps=gateway,tools,postgres-client)'
        required: false
        type: string

env:
  REGISTRY: testnetobscuronet.azurecr.io
  REGISTRY_ORG: obscuronet

jobs:
  # ============================================================================
  # VALIDATION & SETUP
  # ============================================================================
  validate-inputs:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'  # Only run on manual triggers
    outputs:
      TESTNET_SHORT_NAME: ${{ steps.setup.outputs.TESTNET_SHORT_NAME }}
      IS_DESTRUCTIVE: ${{ steps.setup.outputs.IS_DESTRUCTIVE }}
      NEEDS_APPROVAL: ${{ steps.setup.outputs.NEEDS_APPROVAL }}
      CONFIG_PATH: ${{ steps.setup.outputs.CONFIG_PATH }}
      CHILD_APPS: ${{ steps.setup.outputs.CHILD_APPS }}
      ADDITIONAL_APPS_TO_DELETE: ${{ steps.setup.outputs.ADDITIONAL_APPS_TO_DELETE }}

    steps:
      - name: 'Check confirmation for production envs'
        run: |
          if [[ ("${{ github.event.inputs.testnet_type }}" == "sepolia-testnet" || "${{ github.event.inputs.testnet_type }}" == "mainnet") && "${{ github.event.inputs.confirmation }}" != "confirm" ]]; then
            echo "‚ùå Confirmation field must say 'confirm' to deploy to sepolia or mainnet"
            exit 1
          fi

      - name: 'Setup environment variables'
        id: setup
        run: |
          TESTNET_TYPE="${{ github.event.inputs.testnet_type }}"

          # Extract short name
          if [[ "$TESTNET_TYPE" == "mainnet" ]]; then
            SHORT_NAME="mainnet"
          else
            SHORT_NAME=${TESTNET_TYPE%-testnet}
          fi
          echo "TESTNET_SHORT_NAME=$SHORT_NAME" >> $GITHUB_OUTPUT

          # Determine config path
          if [[ "$TESTNET_TYPE" == "mainnet" ]]; then
            CONFIG_PATH="prod-argocd-config"
          else
            CONFIG_PATH="nonprod-argocd-config"
          fi
          echo "CONFIG_PATH=$CONFIG_PATH" >> $GITHUB_OUTPUT

          # Check if destructive
          if [[ "${{ github.event.inputs.deployment_strategy }}" == "destructive" ]]; then
            echo "IS_DESTRUCTIVE=true" >> $GITHUB_OUTPUT
          else
            echo "IS_DESTRUCTIVE=false" >> $GITHUB_OUTPUT
          fi

          # Check if approval needed (destructive + sepolia/mainnet)
          if [[ "${{ github.event.inputs.deployment_strategy }}" == "destructive" && ("$TESTNET_TYPE" == "sepolia-testnet" || "$TESTNET_TYPE" == "mainnet") ]]; then
            echo "NEEDS_APPROVAL=true" >> $GITHUB_OUTPUT
          else
            echo "NEEDS_APPROVAL=false" >> $GITHUB_OUTPUT
          fi

          # Set child apps per environment (for syncing)
          case "$TESTNET_TYPE" in
            dev-testnet)
              echo "CHILD_APPS=dev-sequencer dev-validator-01 dev-validator-02 dev-gateway dev-ten-tools" >> $GITHUB_OUTPUT
              ;;
            uat-testnet)
              echo "CHILD_APPS=uat-sequencer uat-validator-01 uat-validator-02 uat-gateway uat-ten-tools" >> $GITHUB_OUTPUT
              ;;
            sepolia-testnet)
              echo "CHILD_APPS=sepolia-sequencer sepolia-validator-01 sepolia-validator-02 sepolia-gateway sepolia-gateway-dexynth sepolia-gateway-pentest sepolia-ten-tools" >> $GITHUB_OUTPUT
              ;;
            mainnet)
              echo "CHILD_APPS=mainnet-sequencer mainnet-validator-01 mainnet-validator-02 mainnet-gateway mainnet-postgres-client mainnet-ten-tools" >> $GITHUB_OUTPUT
              ;;
          esac

          # Parse destructive_options (if provided, destructive only)
          # Format: node_selectors=sequencer=node1,validator-01=node2,validator-02=node3,gateway=node4|additional_apps=gateway,tools,postgres-client
          DESTRUCTIVE_OPTS="${{ github.event.inputs.destructive_options }}"

          # Extract additional_apps from destructive_options
          if [[ "$DESTRUCTIVE_OPTS" =~ additional_apps=([^|]*) ]]; then
            ADDITIONAL_APPS="${BASH_REMATCH[1]}"
            if [[ -n "$ADDITIONAL_APPS" ]]; then
              # Convert comma-separated to environment-prefixed list
              IFS=',' read -ra APPS <<< "$ADDITIONAL_APPS"
              PREFIXED_APPS=""
              for app in "${APPS[@]}"; do
                app=$(echo "$app" | xargs)  # trim whitespace
                prefixed_app="${SHORT_NAME}-${app}"
                PREFIXED_APPS="$PREFIXED_APPS $prefixed_app"
              done
              echo "ADDITIONAL_APPS_TO_DELETE=$PREFIXED_APPS" >> $GITHUB_OUTPUT
            else
              echo "ADDITIONAL_APPS_TO_DELETE=" >> $GITHUB_OUTPUT
            fi
          else
            echo "ADDITIONAL_APPS_TO_DELETE=" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # APPROVAL GATE (mandatory for sepolia/mainnet, optional for dev/uat)
  # Shows deployment summary and happens AFTER build and config update
  # ============================================================================
  approval:
    needs: [validate-inputs, build-images, update-ten-apps-config]
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.validate-inputs.outputs.NEEDS_APPROVAL == 'true' &&
      (needs.update-ten-apps-config.result == 'success' || needs.update-ten-apps-config.result == 'skipped')
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - name: 'Show deployment summary and request approval'
        run: |
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üö® DEPLOYMENT APPROVAL REQUIRED"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""
          echo "üìã Deployment Summary:"
          echo "  Environment:         ${{ github.event.inputs.testnet_type }}"
          echo "  Strategy:            ${{ github.event.inputs.deployment_strategy }}"
          echo "  Triggered by:        ${{ github.actor }}"
          echo "  Branch:              ${{ github.ref_name }}"
          echo ""
          echo "üê≥ Image Build:"
          if [[ "${{ github.event.inputs.image_build }}" == "yes" ]]; then
            echo "  Status:              ‚úÖ Built"
            echo "  Image Tag:           ${{ needs.build-images.outputs.IMAGE_TAG }}"
            echo "  HSM Signing:         ${{ github.event.inputs.use_azure_hsm == 'yes' && 'üîê Enabled' || 'üì¶ Disabled' }}"
          else
            echo "  Status:              ‚è≠Ô∏è  Skipped (using existing images)"
          fi
          echo ""
          echo "üìù Config Update:"
          if [[ "${{ needs.update-ten-apps-config.result }}" == "success" ]]; then
            echo "  Status:              ‚úÖ Updated ten-apps config"
            echo "  Commit:              Pushed to ten-protocol/ten-apps"
          else
            echo "  Status:              ‚è≠Ô∏è  Skipped"
          fi
          echo ""
          if [[ "${{ github.event.inputs.deployment_strategy }}" == "destructive" ]]; then
            echo "üî• DESTRUCTIVE Deployment Actions:"
            echo "  1. Delete child apps (sequencer, validators)"
            echo "  2. Sync parent app (recreates children)"
            echo "  3. Deploy L1 contracts"
            echo "  4. Sync all ArgoCD apps"
            echo "  5. Deploy L2 contracts"
            echo ""
            echo "‚ö†Ô∏è  WARNING: This will cause downtime!"
          else
            echo "üì¶ NON-DESTRUCTIVE Deployment Actions:"
            echo "  1. Delete host deployment and enclave statefulsets"
            echo "  2. Sync ONLY OutOfSync resources (no sync waves/hooks)"
            echo "  3. Wait for apps to be healthy"
            echo ""
            echo "‚úÖ No L1/L2 contract deployment (minimal disruption)"
          fi
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "Please review and approve to continue"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

  # ============================================================================
  # REVERT CONFIG IF APPROVAL REJECTED
  # ============================================================================
  revert-config-on-rejection:
    needs: [validate-inputs, build-images, update-ten-apps-config, approval]
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.validate-inputs.outputs.NEEDS_APPROVAL == 'true' &&
      needs.update-ten-apps-config.result == 'success' &&
      (needs.approval.result == 'cancelled' || needs.approval.result == 'failure')
    steps:
      - uses: actions/checkout@v4
        with:
          repository: ten-protocol/ten-apps
          token: ${{ secrets.DEPLOY_ACTIONS_PAT }}
          path: ten-apps
          fetch-depth: 2

      - name: 'Revert ten-apps config changes'
        env:
          IMAGE_TAG: ${{ needs.build-images.outputs.IMAGE_TAG }}
        run: |
          cd ten-apps
          
          echo "‚ùå Approval was rejected - reverting ten-apps config changes"
          echo "Image tag that was set: ${IMAGE_TAG}"
          
          # Revert the last commit
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git revert --no-edit HEAD
          git push
          
          echo "‚úÖ Reverted config changes in ten-apps"
          echo "‚ö†Ô∏è  Note: Docker images were already built and pushed (not reverted)"

  # ============================================================================
  # BUILD & PUSH IMAGES (Optional)
  # ============================================================================
  build-images:
    needs: [validate-inputs]
    if: |
      github.event.inputs.image_build == 'yes'
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    outputs:
      IMAGE_TAG: ${{ steps.get_tag.outputs.IMAGE_TAG }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: 1.25.1

      - name: 'Login via Azure CLI (for HSM)'
        if: github.event.inputs.use_azure_hsm == 'yes'
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: 'Login to Azure docker registry'
        uses: azure/docker-login@v1
        with:
          login-server: testnetobscuronet.azurecr.io
          username: testnetobscuronet
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: 'Determine image tag'
        id: get_tag
        run: |
          # Use provided tag, or git tag, or commit hash
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          else
            # Try git tag first, fall back to short commit hash
            IMAGE_TAG=$(git describe --tags --exact-match 2>/dev/null || git rev-parse --short HEAD)
          fi
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "üì¶ Image tag: $IMAGE_TAG"
          echo "::set-output name=IMAGE_TAG::$IMAGE_TAG"

      - name: 'Build and push obscuro node images'
        env:
          IMAGE_TAG: ${{ steps.get_tag.outputs.IMAGE_TAG }}
          USE_HSM: ${{ github.event.inputs.use_azure_hsm }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: |
          set -e
          
          # Enable Docker BuildKit for better caching and parallel builds
          export DOCKER_BUILDKIT=1
          export BUILDKIT_PROGRESS=plain
          
          echo "üèóÔ∏è  Building images with tag: ${IMAGE_TAG}"
          echo "Using Docker BuildKit with layer caching"
          
          # Function to build and push in background
          build_and_push() {
            local name=$1
            local dockerfile=$2
            local extra_args=$3
            
            echo "Building ${name}..."
            docker build \
              --cache-from ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/${name}:latest \
              --cache-from ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/${name}:${IMAGE_TAG} \
              -t ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/${name}:${IMAGE_TAG} \
              -f ${dockerfile} \
              ${extra_args} \
              . 2>&1 | sed "s/^/[${name}] /" &
          }
          
          # Build enclave (with optional HSM)
          if [[ "$USE_HSM" == "yes" ]]; then
            echo "üîê Building enclave with Azure HSM..."
            build_and_push "enclave" "dockerfiles/enclave.Dockerfile" \
              "--build-arg AZURE_TENANT_ID=${AZURE_TENANT_ID} --build-arg AZURE_SUBSCRIPTION_ID=${AZURE_SUBSCRIPTION_ID}"
          else
            echo "üì¶ Building enclave without HSM..."
            build_and_push "enclave" "dockerfiles/enclave.Dockerfile" ""
          fi
          
          # Build host and hardhat deployer in parallel
          build_and_push "host" "dockerfiles/host.Dockerfile" ""
          build_and_push "hardhatdeployer" "tools/hardhatdeployer/Dockerfile" ""
          
          # Wait for all builds to complete
          echo "‚è≥ Waiting for all builds to complete..."
          wait
          
          # Check if any build failed
          if [ $? -ne 0 ]; then
            echo "‚ùå One or more builds failed"
            exit 1
          fi
          
          echo "‚úÖ All builds completed successfully"
          echo ""
          echo "üì§ Pushing images..."
          
          # Push all images in parallel
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/enclave:${IMAGE_TAG} &
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/host:${IMAGE_TAG} &
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/hardhatdeployer:${IMAGE_TAG} &
          
          # Wait for all pushes
          wait
          
          echo "‚úÖ All images built and pushed with tag: ${IMAGE_TAG}"

  # ============================================================================
  # UPDATE TEN-APPS YAML WITH IMAGE TAGS AND DESTRUCTIVE FLAG
  # ============================================================================
  update-ten-apps-config:
    needs: [validate-inputs, build-images]
    if: |
      always() &&
      (needs.build-images.result == 'success' || needs.build-images.result == 'skipped')
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - uses: actions/checkout@v4
        with:
          repository: ten-protocol/ten-apps
          token: ${{ secrets.DEPLOY_ACTIONS_PAT }}
          path: ten-apps

      - name: 'Install yq'
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.1/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: 'Update image tags and node selectors in ten-apps config'
        env:
          IMAGE_TAG: ${{ needs.build-images.outputs.IMAGE_TAG }}
          CONFIG_PATH: ${{ needs.validate-inputs.outputs.CONFIG_PATH }}
          DESTRUCTIVE_OPTIONS_INPUT: ${{ github.event.inputs.destructive_options }}
          IS_DESTRUCTIVE: ${{ needs.validate-inputs.outputs.IS_DESTRUCTIVE }}
        run: |
          cd ten-apps

          # Determine the config directory
          if [[ "${{ github.event.inputs.testnet_type }}" == "mainnet" ]]; then
            ENV_DIR="${{ env.CONFIG_PATH }}/apps/envs/mainnet/valuesFile"
          else
            ENV_DIR="${{ env.CONFIG_PATH }}/apps/envs/${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}/valuesFile"
          fi

          # Update image tags if provided
          if [[ -n "${IMAGE_TAG}" ]]; then
            echo "üìù Updating image tags to: ${IMAGE_TAG} in $ENV_DIR"
          else
            echo "‚ÑπÔ∏è  No image tag to update (skipped image build)"
          fi
          
          echo "üîß Setting destructiveDeployment flag to: ${IS_DESTRUCTIVE}"

          # Update all values files
          for values_file in "$ENV_DIR"/values-*.yaml; do
            if [ -f "$values_file" ]; then
              filename=$(basename "$values_file")
              echo "  Updating $filename..."

              # Update image tags for core images (only if IMAGE_TAG is set)
              if [[ -n "${IMAGE_TAG}" ]]; then
                yq eval -i ".enclave.image.tag = \"${IMAGE_TAG}\"" "$values_file" 2>/dev/null || true
                yq eval -i ".enclave02.image.tag = \"${IMAGE_TAG}\"" "$values_file" 2>/dev/null || true
                yq eval -i ".host.image.tag = \"${IMAGE_TAG}\"" "$values_file" 2>/dev/null || true

                # For gateway values files
                yq eval -i ".gateway.image.tag = \"${IMAGE_TAG}\"" "$values_file" 2>/dev/null || true
              fi
              
              # Always update destructiveDeployment flag in global section
              if [[ "${IS_DESTRUCTIVE}" == "true" ]]; then
                yq eval -i ".global.destructiveDeployment = true" "$values_file" 2>/dev/null || true
              else
                yq eval -i ".global.destructiveDeployment = false" "$values_file" 2>/dev/null || true
              fi
            fi
          done

          if [[ -n "${IMAGE_TAG}" ]]; then
            echo "‚úÖ Image tags and destructiveDeployment flag updated"
          else
            echo "‚úÖ destructiveDeployment flag updated"
          fi

          # ‚ö†Ô∏è  NODE SELECTORS ONLY FOR DESTRUCTIVE DEPLOYMENTS
          # Extract node_selectors from destructive_options
          NODE_SELECTORS_INPUT=""
          if [[ "${{ env.DESTRUCTIVE_OPTIONS_INPUT }}" =~ node_selectors=([^|]*) ]]; then
            NODE_SELECTORS_INPUT="${BASH_REMATCH[1]}"
          fi

          if [[ "${{ env.IS_DESTRUCTIVE }}" == "true" ]] && [[ -n "$NODE_SELECTORS_INPUT" ]]; then
            echo "üî• DESTRUCTIVE deployment: Parsing and applying node selectors"

            # Parse node_selectors input (format: sequencer=node1,validator-01=node2,validator-02=node3,gateway=node4)
            declare -A node_selectors
            IFS=',' read -ra pairs <<< "$NODE_SELECTORS_INPUT"
            for pair in "${pairs[@]}"; do
              key="${pair%%=*}"
              value="${pair##*=}"
              node_selectors["$key"]="$value"
            done

            # Update sequencer node selector (if provided)
            if [[ -n "${node_selectors[sequencer]}" ]]; then
              echo "üìç Updating sequencer node selector to: ${node_selectors[sequencer]}"
              seq_file="$ENV_DIR/values-${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}-sequencer.yaml"
              if [ -f "$seq_file" ]; then
                yq eval -i ".enclave.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[sequencer]}\"" "$seq_file"
                yq eval -i ".enclave02.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[sequencer]}\"" "$seq_file" 2>/dev/null || true
                yq eval -i ".host.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[sequencer]}\"" "$seq_file"
                echo "‚úÖ Sequencer node selector updated"
              fi
            fi

            # Update validator-01 node selector (if provided)
            if [[ -n "${node_selectors[validator-01]}" ]]; then
              echo "üìç Updating validator-01 node selector to: ${node_selectors[validator-01]}"
              val1_file="$ENV_DIR/values-${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}-validator-01.yaml"
              if [ -f "$val1_file" ]; then
                yq eval -i ".enclave.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[validator-01]}\"" "$val1_file"
                yq eval -i ".enclave02.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[validator-01]}\"" "$val1_file" 2>/dev/null || true
                yq eval -i ".host.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[validator-01]}\"" "$val1_file"
                echo "‚úÖ Validator-01 node selector updated"
              fi
            fi

            # Update validator-02 node selector (if provided)
            if [[ -n "${node_selectors[validator-02]}" ]]; then
              echo "üìç Updating validator-02 node selector to: ${node_selectors[validator-02]}"
              val2_file="$ENV_DIR/values-${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}-validator-02.yaml"
              if [ -f "$val2_file" ]; then
                yq eval -i ".enclave.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[validator-02]}\"" "$val2_file"
                yq eval -i ".enclave02.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[validator-02]}\"" "$val2_file" 2>/dev/null || true
                yq eval -i ".host.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[validator-02]}\"" "$val2_file"
                echo "‚úÖ Validator-02 node selector updated"
              fi
            fi

            # Update gateway node selector (if provided)
            if [[ -n "${node_selectors[gateway]}" ]]; then
              echo "üìç Updating gateway node selector to: ${node_selectors[gateway]}"
              gw_file="$ENV_DIR/values-${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}-gateway.yaml"
              if [ -f "$gw_file" ]; then
                yq eval -i ".gateway.nodeSelector.[\"kubernetes.io/hostname\"] = \"${node_selectors[gateway]}\"" "$gw_file"
                echo "‚úÖ Gateway node selector updated"
              fi
            fi
          elif [[ "${{ env.IS_DESTRUCTIVE }}" != "true" ]]; then
            echo "üìå NON-DESTRUCTIVE deployment: Skipping node selector updates"
          else
            echo "‚ÑπÔ∏è  No node selectors provided"
          fi

          # Commit changes
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add "$ENV_DIR/values-*.yaml"

          if git diff --cached --quiet; then
            echo "‚ÑπÔ∏è  No changes to commit"
          else
            commit_msg="chore: update "
            
            # Build commit message based on what changed
            changes=()
            [[ -n "${IMAGE_TAG}" ]] && changes+=("image tags to ${IMAGE_TAG}")
            [[ "${IS_DESTRUCTIVE}" == "true" ]] && changes+=("destructiveDeployment=true") || changes+=("destructiveDeployment=false")
            [[ "${IS_DESTRUCTIVE}" == "true" ]] && [[ -n "$NODE_SELECTORS_INPUT" ]] && changes+=("node selectors")
            
            # Join changes with comma
            commit_msg+=$(IFS=", "; echo "${changes[*]}")
            commit_msg+=" for ${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}"

            git commit -m "$commit_msg"
            git push
            echo "‚úÖ Updated and pushed changes to ten-apps"
          fi

  # ============================================================================
  # DEPLOY L1 CONTRACTS (Destructive only)
  # ============================================================================
  deploy-l1-contracts:
    needs: [validate-inputs, approval, update-ten-apps-config]
    if: |
      (needs.validate-inputs.outputs.NEEDS_APPROVAL == 'false' || success()) &&
      needs.validate-inputs.outputs.IS_DESTRUCTIVE == 'true'
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    outputs:
      NETWORK_CONFIG_ADDR: ${{ steps.deploy.outputs.NETWORK_CONFIG_ADDR }}
      MSG_BUS_CONTRACT_ADDR: ${{ steps.deploy.outputs.MSG_BUS_CONTRACT_ADDR }}
      BRIDGE_CONTRACT_ADDR: ${{ steps.deploy.outputs.BRIDGE_CONTRACT_ADDR }}
      CROSS_CHAIN_ADDR: ${{ steps.deploy.outputs.CROSS_CHAIN_ADDR }}
      DA_REGISTRY_ADDR: ${{ steps.deploy.outputs.DA_REGISTRY_ADDR }}
      ENCLAVE_REGISTRY_ADDR: ${{ steps.deploy.outputs.ENCLAVE_REGISTRY_ADDR }}
      L1_START_HASH: ${{ steps.deploy.outputs.L1_START_HASH }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: 1.25.1

      - name: 'Login via Azure CLI'
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: 'Login to Azure docker registry'
        uses: azure/docker-login@v1
        with:
          login-server: ${{ env.REGISTRY }}
          username: testnetobscuronet
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: 'Deploy Contracts'
        id: deployContracts
        shell: bash
        env:
          DOCKER_API_VERSION: "1.45"
          DEPLOY_DOCKERIMAGE: ${{ vars.DOCKER_BUILD_TAG_L2_HARDHAT_DEPLOYER }}
          DEPLOY_NETWORKNAME: ${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}
          DEPLOY_GITHUBPAT: ${{ secrets.DEPLOY_ACTIONS_PAT }}
          DEPLOY_OUTPUTENV: ./testnet/.env
          DEPLOY_L1_RPCADDRESS: ${{ secrets.L1_HTTP_URL }}
          DEPLOY_L1_DEPLOYERPK: ${{ secrets.ACCOUNT_PK_WORKER }}
          DEPLOY_L1_INITIALSEQADDRESS: ${{ vars.ACCOUNT_ADDR_NODE_0 }}
          DEPLOY_L1_ETHERSCANAPIKEY: ${{ secrets.ETHERSCAN_API_KEY }}
          DEPLOY_L1_MAXGASGWEI: ${{ github.event.inputs.max_gas_gwei }}
          DEPLOY_L1_CHECKGASPRICE: ${{ github.event.inputs.testnet_type == 'mainnet' && 'true' || 'false' }}
        run: |
          # Run deployer and capture output
          go run ./testnet/launcher/l1contractdeployer/cmd
          
          if [ -f ./testnet/.env ]; then
            source ./testnet/.env
          fi          
          # Fix variable names and GITHUB_OUTPUT reference
          echo "NETWORK_CONFIG_ADDR=$NETWORKCONFIGADDR" >> $GITHUB_ENV
          echo "NETWORK_CONFIG_ADDR=$NETWORKCONFIGADDR" >> $GITHUB_OUTPUT
          
          echo "MSG_BUS_CONTRACT_ADDR=$MSGBUSCONTRACTADDR" >> $GITHUB_ENV
          echo "MSG_BUS_CONTRACT_ADDR=$MSGBUSCONTRACTADDR" >> $GITHUB_OUTPUT
          
          echo "BRIDGE_CONTRACT_ADDR=$BRIDGECONTRACTADDR" >> $GITHUB_ENV
          echo "BRIDGE_CONTRACT_ADDR=$BRIDGECONTRACTADDR" >> $GITHUB_OUTPUT
          
          echo "CROSS_CHAIN_ADDR=$CROSSCHAINADDR" >> $GITHUB_ENV
          echo "CROSS_CHAIN_ADDR=$CROSSCHAINADDR" >> $GITHUB_OUTPUT
          
          echo "DA_REGISTRY_ADDR=$DAREGISTRYADDR" >> $GITHUB_ENV
          echo "DA_REGISTRY_ADDR=$DAREGISTRYADDR" >> $GITHUB_OUTPUT
          
          echo "ENCLAVE_REGISTRY_ADDR=$ENCLAVEREGISTRYADDR" >> $GITHUB_ENV
          echo "ENCLAVE_REGISTRY_ADDR=$ENCLAVEREGISTRYADDR" >> $GITHUB_OUTPUT
          
          echo "L1_START_HASH=$L1START" >> $GITHUB_ENV
          echo "L1_START_HASH=$L1START" >> $GITHUB_OUTPUT

      - name: 'Save L1 deployer container logs'
        # Wait to make sure the logs are available in the container
        if: ${{ always() }} # Always run this step to ensure logs are captured even if previous steps fail
        run: |
          sleep 60
          docker logs `docker ps -aqf "name=hh-l1-deployer"` > deploy-l1-contracts.out 2>&1
          
      - name: 'Upload L1 deployer container logs'
        if: ${{ always() }} # Always run this step to ensure logs are uploaded even if previous steps fail
        uses: actions/upload-artifact@v4
        with:
          name: deploy-l1-artifacts
          path: |
            deploy-l1-contracts.out
          retention-days: 2

  # ============================================================================
  # ARGOCD - DELETE CHILD APPS (Destructive only)
  # ============================================================================
  argocd-delete-child-apps:
    needs: [validate-inputs, approval, deploy-l1-contracts]
    if: |
      (needs.validate-inputs.outputs.NEEDS_APPROVAL == 'false' || success()) &&
      needs.validate-inputs.outputs.IS_DESTRUCTIVE == 'true'
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - name: 'Install ArgoCD CLI'
        run: |
          curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x /usr/local/bin/argocd

      - name: 'Login to ArgoCD'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_USERNAME: ${{ secrets.ARGOCD_USERNAME }}
          ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
        run: |
          set -e
          
          echo "üîê Logging in to ArgoCD server: ${ARGOCD_SERVER}"
          
          if [[ -z "${ARGOCD_SERVER}" ]] || [[ -z "${ARGOCD_USERNAME}" ]] || [[ -z "${ARGOCD_PASSWORD}" ]]; then
            echo "‚ùå ERROR: ArgoCD credentials not set!"
            exit 1
          fi
          
          argocd login "${ARGOCD_SERVER}" \
            --username "${ARGOCD_USERNAME}" \
            --password "${ARGOCD_PASSWORD}" \
            --insecure
          
          echo "‚úÖ Successfully logged in to ArgoCD"

      - name: 'Delete ArgoCD child applications and sync parent'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          DEFAULT_APPS: "sequencer validator-01 validator-02"
          ADDITIONAL_APPS: ${{ needs.validate-inputs.outputs.ADDITIONAL_APPS_TO_DELETE }}
          TESTNET_SHORT_NAME: ${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}
        run: |
          set -e

          echo "üî• DESTRUCTIVE DEPLOYMENT: Delete child apps and sync parent"
          echo "Environment: ${{ github.event.inputs.testnet_type }}"
          echo ""
          
          # Validate required variables
          if [[ -z "${ARGOCD_SERVER}" ]]; then
            echo "‚ùå ERROR: ARGOCD_SERVER is not set!"
            exit 1
          fi
          
          # Determine parent app name based on environment
          PARENT_APP="ten-${TESTNET_SHORT_NAME}-apps"
          echo "üìå Parent app: $PARENT_APP"
          echo ""

          # Step 1: Delete child apps
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "STEP 1: Delete child applications"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          
          # Always delete default apps (sequencer, validator-01, validator-02)
          echo "Default apps to delete: sequencer, validator-01, validator-02"
          for app_suffix in ${DEFAULT_APPS}; do
            app="${TESTNET_SHORT_NAME}-${app_suffix}"
            echo "  üóëÔ∏è  Deleting: $app"
            if ! argocd app delete "$app" --server "${ARGOCD_SERVER}" --cascade --yes 2>&1 | tee /tmp/argocd_output.txt; then
              if grep -q "NotFound\|not found" /tmp/argocd_output.txt; then
                echo "     ‚ÑπÔ∏è  App not found (this is OK)"
              else
                echo "     ‚ùå Failed to delete app"
                exit 1
              fi
            else
              echo "     ‚úÖ Deleted"
            fi
            sleep 2
          done

          # Delete additional apps if specified
          if [[ -n "${ADDITIONAL_APPS}" ]]; then
            echo ""
            echo "Additional apps to delete: ${ADDITIONAL_APPS}"
            for app in ${ADDITIONAL_APPS}; do
              echo "  üóëÔ∏è  Deleting: $app"
              if ! argocd app delete "$app" --server "${ARGOCD_SERVER}" --cascade --yes 2>&1 | tee /tmp/argocd_output.txt; then
                if grep -q "NotFound\|not found" /tmp/argocd_output.txt; then
                  echo "     ‚ÑπÔ∏è  App not found (this is OK)"
                else
                  echo "     ‚ùå Failed to delete app"
                  exit 1
                fi
              else
                echo "     ‚úÖ Deleted"
              fi
              sleep 2
            done
          fi
          
          echo ""
          echo "‚úÖ Child apps deleted"
          echo ""
          
          # Step 2: Sync parent app to recreate child apps
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "STEP 2: Sync parent app to recreate children"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üîÑ Syncing parent app: $PARENT_APP"
          
          if argocd app sync "$PARENT_APP" --server "${ARGOCD_SERVER}" --grpc-web; then
            echo "‚úÖ Parent app synced - child apps should be recreated"
          else
            echo "‚ùå Failed to sync parent app"
            exit 1
          fi
          
          echo ""
          echo "‚è≥ Waiting 10 seconds for child apps to be created..."
          sleep 10
          
          echo ""
          echo "‚úÖ Destructive delete and recreate complete"
          echo "   Child apps will be fully synced in the next job"



  # ============================================================================
  # ARGOCD - SYNC APPLICATIONS
  # ============================================================================
  argocd-sync-apps:
    needs: [validate-inputs, approval, deploy-l1-contracts, argocd-delete-child-apps]
    if: |
      always() &&
      (needs.validate-inputs.outputs.NEEDS_APPROVAL == 'false' || success()) &&
      (needs.argocd-delete-child-apps.result == 'success' || needs.argocd-delete-child-apps.result == 'skipped')
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    outputs:
      APPS_SYNCED: ${{ steps.sync.outputs.APPS_SYNCED }}

    steps:
      - name: 'Install ArgoCD CLI'
        run: |
          curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x /usr/local/bin/argocd

      - name: 'Login to ArgoCD'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_USERNAME: ${{ secrets.ARGOCD_USERNAME }}
          ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
        run: |
          set -e
          
          echo "üîê Logging in to ArgoCD server: ${ARGOCD_SERVER}"
          
          if [[ -z "${ARGOCD_SERVER}" ]] || [[ -z "${ARGOCD_USERNAME}" ]] || [[ -z "${ARGOCD_PASSWORD}" ]]; then
            echo "‚ùå ERROR: ArgoCD credentials not set!"
            exit 1
          fi
          
          argocd login "${ARGOCD_SERVER}" \
            --username "${ARGOCD_USERNAME}" \
            --password "${ARGOCD_PASSWORD}" \
            --insecure
          
          echo "‚úÖ Successfully logged in to ArgoCD"

      - name: 'Sync ArgoCD child applications'
        id: sync
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          CHILD_APPS: ${{ needs.validate-inputs.outputs.CHILD_APPS }}
          SYNC_TIMEOUT: ${{ github.event.inputs.sync_timeout }}
          IS_DESTRUCTIVE: ${{ needs.validate-inputs.outputs.IS_DESTRUCTIVE }}
          TESTNET_SHORT_NAME: ${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}
        run: |
          set -e

          echo "üîÑ Syncing ArgoCD child applications"
          echo "Strategy: ${{ needs.validate-inputs.outputs.IS_DESTRUCTIVE == 'true' && 'Destructive (full sync with all sync waves/hooks)' || 'Non-Destructive (full sync but chart reads destructiveDeployment=false)' }}"
          
          # Validate required variables
          if [[ -z "${ARGOCD_SERVER}" ]]; then
            echo "‚ùå ERROR: ARGOCD_SERVER is not set!"
            exit 1
          fi

          # First, sync parent to propagate config
          PARENT_APP="ten-${TESTNET_SHORT_NAME}-apps"
          echo "üîÑ Ensuring parent app \"$PARENT_APP\" is synced first"
          if ! argocd app sync "$PARENT_APP" --server "${ARGOCD_SERVER}" --grpc-web; then
            echo "‚ö†Ô∏è  Parent app sync failed or not necessary; continuing"
          fi

          sync_failed=false
          failed_apps=""
          synced_count=0

          echo ""
          echo "üîÑ Starting parallel sync of all child apps..."
          echo ""

          # Sync all apps in parallel using background jobs
          pids=()
          for app in ${CHILD_APPS}; do
            (
              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              echo "Processing app: $app"
              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              
              # Check overall sync status before
              app_status=$(argocd app get "$app" --server "${ARGOCD_SERVER}" --grpc-web -o json)
              sync_status=$(echo "$app_status" | jq -r '.status.sync.status // "Unknown"')
              echo "  üìä Sync status before: $sync_status"
              
              # Always do full app sync (chart handles destructive vs non-destructive via global.destructiveDeployment flag)
              echo "  üîÑ Performing full app sync (chart reads destructiveDeployment flag)"
              
              # Run sync - only fail on command failure, not OutOfSync status or deleting apps
              if argocd app sync "$app" --server "${ARGOCD_SERVER}" --grpc-web --prune=false 2>&1 | tee /tmp/sync_output_${app}.txt; then
                echo "  ‚úÖ Sync command completed: $app"
                
                # Check if still OutOfSync (informational only, not a failure)
                app_status_after=$(argocd app get "$app" --server "${ARGOCD_SERVER}" --grpc-web -o json)
                sync_status_after=$(echo "$app_status_after" | jq -r '.status.sync.status // "Unknown"')
                if [[ "$sync_status_after" == "OutOfSync" ]]; then
                  echo "  ‚ÑπÔ∏è  App still OutOfSync after sync (may be resource limits, replicas adjusting, etc.)"
                else
                  echo "  üìä Sync status after: $sync_status_after"
                fi
                
                echo "$app" >> /tmp/sync_success.txt
              else
                # Check if failure is due to app being deleted (not a real failure)
                if grep -qi "application is deleting\|permission denied" /tmp/sync_output_${app}.txt; then
                  echo "  ‚ö†Ô∏è  App is being deleted or recreated, will sync on next deployment"
                  echo "$app" >> /tmp/sync_success.txt
                else
                  echo "  ‚ùå Sync command failed: $app"
                  cat /tmp/sync_output_${app}.txt
                  echo "$app" >> /tmp/sync_failed.txt
                fi
              fi
              rm -f /tmp/sync_output_${app}.txt
            ) &
            pids+=($!)
          done

          # Wait for all parallel syncs to complete
          echo "‚è≥ Waiting for all parallel syncs to complete..."
          for pid in "${pids[@]}"; do
            wait $pid
          done
          echo ""
          echo "‚úÖ All parallel syncs finished"
          echo ""

          # Check results
          if [ -f /tmp/sync_success.txt ]; then
            synced_count=$(wc -l < /tmp/sync_success.txt | tr -d ' ')
          fi
          
          if [ -f /tmp/sync_failed.txt ]; then
            sync_failed=true
            failed_apps=$(cat /tmp/sync_failed.txt | tr '\n' ' ')
          fi

          # Cleanup temp files
          rm -f /tmp/sync_success.txt /tmp/sync_failed.txt

          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üìä Sync Summary"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "  Strategy: ${{ needs.validate-inputs.outputs.IS_DESTRUCTIVE == 'true' && 'Destructive' || 'Non-Destructive' }}"
          echo "  Apps synced: $synced_count"
          
          if [ "$sync_failed" = true ]; then
            echo "  Apps failed: $(echo $failed_apps | wc -w)"
            echo ""
            echo "‚ùå ERROR: Failed to sync the following apps:${failed_apps}"
            echo "Deployment cannot continue with failed syncs."
            exit 1
          fi

          echo ""
          echo "‚úÖ All apps synced successfully (health will be checked in next job)"
          echo "APPS_SYNCED=true" >> $GITHUB_OUTPUT

  # ============================================================================
  # WAIT FOR ARGOCD APPS TO BE HEALTHY
  # ============================================================================
  wait-argocd-healthy:
    needs: [validate-inputs, argocd-sync-apps]
    if: success()
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - name: 'Install ArgoCD CLI'
        run: |
          curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x /usr/local/bin/argocd

      - name: 'Login to ArgoCD'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_USERNAME: ${{ secrets.ARGOCD_USERNAME }}
          ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
        run: |
          set -e
          
          echo "üîê Logging in to ArgoCD server: ${ARGOCD_SERVER}"
          
          if [[ -z "${ARGOCD_SERVER}" ]] || [[ -z "${ARGOCD_USERNAME}" ]] || [[ -z "${ARGOCD_PASSWORD}" ]]; then
            echo "‚ùå ERROR: ArgoCD credentials not set!"
            exit 1
          fi
          
          argocd login "${ARGOCD_SERVER}" \
            --username "${ARGOCD_USERNAME}" \
            --password "${ARGOCD_PASSWORD}" \
            --insecure
          
          echo "‚úÖ Successfully logged in to ArgoCD"

      - name: 'Wait for ArgoCD apps to be healthy'
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          CHILD_APPS: ${{ needs.validate-inputs.outputs.CHILD_APPS }}
        run: |
          set -e

          echo "‚è≥ Waiting for ArgoCD applications to reach healthy state"

          max_attempts=30
          attempt=1

          for app in ${CHILD_APPS}; do
            echo "Checking health of app: $app"
            attempt=1
            while [ $attempt -le $max_attempts ]; do
              health=$(argocd app get "$app" --server "${ARGOCD_SERVER}" --refresh --output json | jq -r '.status.health.status // "Unknown"')
              sync=$(argocd app get "$app" --server "${ARGOCD_SERVER}" --refresh --output json | jq -r '.status.operationState.phase // "Unknown"')

              echo "  Attempt $attempt/$max_attempts: Health=$health, Sync=$sync"

              if [[ "$health" == "Healthy" ]] && [[ "$sync" != "Running" ]]; then
                echo "‚úÖ App $app is healthy"
                break
              fi

              if [ $attempt -eq $max_attempts ]; then
                echo "‚ö†Ô∏è  App $app did not reach healthy state within timeout"
              fi

              attempt=$((attempt + 1))
              sleep 10
            done
          done

          echo "‚úÖ Health check complete"

  # ============================================================================
  # DEPLOY L2 CONTRACTS (Destructive only)
  # ============================================================================
  deploy-l2-contracts:
    needs: [validate-inputs, deploy-l1-contracts, wait-argocd-healthy]
    if: |
      (needs.validate-inputs.outputs.NEEDS_APPROVAL == 'false' || success()) &&
      needs.validate-inputs.outputs.IS_DESTRUCTIVE == 'true'
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/checkout@v4
        with:
          repository: ten-protocol/ten-apps
          token: ${{ secrets.DEPLOY_ACTIONS_PAT }}
          path: cfg

      - uses: actions/setup-go@v5
        with:
          go-version: 1.25.1

      - name: 'Login via Azure CLI'
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: 'Login to Azure docker registry'
        uses: azure/docker-login@v1
        with:
          login-server: ${{ env.REGISTRY }}
          username: testnetobscuronet
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: 'Parse L1 config'
        id: parse_l1_config
        env:
          CONFIG_PATH: ${{ needs.validate-inputs.outputs.CONFIG_PATH }}
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.1/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

          # Determine config file
          if [[ "${{ github.event.inputs.testnet_type }}" == "mainnet" ]]; then
            CFG="cfg/${{ env.CONFIG_PATH }}/apps/envs/mainnet/valuesFile/l1-values.yaml"
          else
            CFG="cfg/${{ env.CONFIG_PATH }}/apps/envs/${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}/valuesFile/l1-values.yaml"
          fi

          echo "network_config=$(yq -r '.l1Config.networkConfig' "$CFG")" >> $GITHUB_OUTPUT
          echo "message_bus=$(yq -r '.l1Config.messagebus' "$CFG")" >> $GITHUB_OUTPUT
          echo "rollup=$(yq -r '.l1Config.rollup' "$CFG")" >> $GITHUB_OUTPUT
          echo "crosschain=$(yq -r '.l1Config.crosschain' "$CFG")" >> $GITHUB_OUTPUT
          echo "enclave_registry=$(yq -r '.l1Config.enclaveRegistry' "$CFG")" >> $GITHUB_OUTPUT

      - name: 'Deploy L2 contracts'
        id: deployL2Contracts
        shell: bash
        env:
          DOCKER_API_VERSION: "1.45"
          DEPLOY_DOCKERIMAGE: ${{ env.REGISTRY }}/${{ env.REGISTRY_ORG }}/hardhatdeployer:${{ needs.build-images.outputs.IMAGE_TAG || github.event.inputs.image_tag || 'latest' }}
          DEPLOY_L1_DEPLOYERPK: ${{ secrets.ACCOUNT_PK_WORKER }}
          DEPLOY_L1_RPCADDRESS: ${{ secrets.L1_HTTP_URL }}
          DEPLOY_L2_DEPLOYERPK: ${{ secrets.L2_DEPLOYER_KEY }}
          DEPLOY_L2_RPCADDRESS: ${{ needs.validate-inputs.outputs.TESTNET_SHORT_NAME }}-validator-01.ten.xyz
          DEPLOY_L2_HTTPPORT: 80
          DEPLOY_L2_WSPORT: 81
          DEPLOY_L2_FAUCETPREFUND: ${{ vars.FAUCET_INITIAL_FUNDS }}
          NETWORK_L1_CONTRACTS_NETWORKCONFIG: ${{ steps.parse_l1_config.outputs.network_config }}
          NETWORK_L1_CONTRACTS_MESSAGEBUS: ${{ steps.parse_l1_config.outputs.message_bus }}
          NETWORK_L1_CONTRACTS_ROLLUP: ${{ steps.parse_l1_config.outputs.rollup }}
          NETWORK_L1_CONTRACTS_CROSSCHAIN: ${{ steps.parse_l1_config.outputs.crosschain }}
          NETWORK_L1_CONTRACTS_ENCLAVEREGISTRY: ${{ steps.parse_l1_config.outputs.enclave_registry }}
          NETWORK_CHAINID: ${{ vars.CHAIN_ID }}
        run: |
          go run ./testnet/launcher/l2contractdeployer/cmd \

      - name: 'Save L2 deployer container logs'
        if: ${{ always() }} # Always run this step to ensure logs are captured even if previous steps fail
        run: |
          docker logs `docker ps -aqf "name=hh-l2-deployer"` > deploy-l2-contracts.out 2>&1

      - name: 'Upload L2 deployer container logs'
        if: ${{ always() }} # Always run this step to ensure logs are uploaded even if previous steps fail
        uses: actions/upload-artifact@v4
        with:
          name: deploy-l2-artifacts
          path: |
            deploy-l2-contracts.out
          retention-days: 2

  # ============================================================================
  # POST-DEPLOYMENT NOTIFICATION
  # ============================================================================
  post-deployment:
    needs: [validate-inputs, deploy-l1-contracts, deploy-l2-contracts]
    if: |
      always() &&
      (needs.validate-inputs.outputs.NEEDS_APPROVAL == 'false' || success())
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.testnet_type }}
    steps:
      - uses: actions/checkout@v4

      - name: 'Deployment summary'
        run: |
          echo "‚úÖ Deployment workflow completed"
          echo "Environment: ${{ github.event.inputs.testnet_type }}"
          echo "Strategy: ${{ github.event.inputs.deployment_strategy }}"
          echo "Images built: ${{ github.event.inputs.image_build }}"
          echo "Actor: ${{ github.actor }}"

      - name: 'Send repository dispatch to ten-test'
        if: github.event.inputs.testnet_type == 'dev-testnet' || github.event.inputs.testnet_type == 'uat-testnet'
        run: |
          event_type=""
          if [[ "${{ github.event.inputs.testnet_type }}" == "dev-testnet" ]]; then
            event_type="dev_testnet_deployed"
          elif [[ "${{ github.event.inputs.testnet_type }}" == "uat-testnet" ]]; then
            event_type="uat_testnet_deployed"
          fi

          curl -XPOST \
            -H "Authorization: Bearer ${{ secrets.GH_TOKEN }}" \
            -H "Accept: application/vnd.github" \
            -H "Content-Type: application/json" \
            https://api.github.com/repos/ten-protocol/ten-test/dispatches \
            --data "{\"event_type\": \"$event_type\", \"client_payload\": {\"ref\": \"${{ github.ref_name }}\"}}"
